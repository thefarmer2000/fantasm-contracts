{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/farms/WonderfulChef.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../interfaces/IWonderfulStaking.sol\";\r\nimport \"../interfaces/IRewarder.sol\";\r\n\r\ncontract WonderfulChef is Ownable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        int256 rewardDebt;\r\n    }\r\n\r\n    struct PoolInfo {\r\n        uint256 accRewardPerShare;\r\n        uint256 lastRewardTime;\r\n        uint256 allocPoint;\r\n    }\r\n\r\n    IWonderfulStaking public rewardMinter;\r\n\r\n    /// @notice Info of each MCV2 pool.\r\n    PoolInfo[] public poolInfo;\r\n    /// @notice Address of the LP token for each MCV2 pool.\r\n    IERC20[] public lpToken;\r\n    /// @notice Address of each `IRewarder` contract in MCV2.\r\n    IRewarder[] public rewarder;\r\n\r\n    /// @notice Info of each user that stakes LP tokens.\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n    /// @dev Total allocation points. Must be the sum of all allocation points in all pools.\r\n    uint256 public totalAllocPoint = 0;\r\n\r\n    uint256 public rewardPerSecond;\r\n    uint256 private constant ACC_REWARD_PRECISION = 1e12;\r\n    uint256 private constant MAX_REWARD_PER_SECOND = 1e18; // 1 token per second\r\n    uint256 private constant MAX_NUM_OF_POOLS = 24;\r\n\r\n    /* ========== PUBLIC FUNCTIONS ========== */\r\n\r\n    /// @notice Returns the number of MCV2 pools.\r\n    function poolLength() public view returns (uint256 pools) {\r\n        pools = poolInfo.length;\r\n    }\r\n\r\n    /// @notice View function to see pending reward on frontend.\r\n    /// @param _pid The index of the pool. See `poolInfo`.\r\n    /// @param _user Address of user.\r\n    /// @return pending reward for a given user.\r\n    function pendingReward(uint256 _pid, address _user) external view returns (uint256 pending) {\r\n        PoolInfo memory pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accRewardPerShare = pool.accRewardPerShare;\r\n        uint256 lpSupply = lpToken[_pid].balanceOf(address(this));\r\n        if (block.timestamp > pool.lastRewardTime && lpSupply != 0) {\r\n            uint256 time = block.timestamp - pool.lastRewardTime;\r\n            uint256 rewardAmount = (time * rewardPerSecond * pool.allocPoint) / totalAllocPoint;\r\n            accRewardPerShare += (rewardAmount * ACC_REWARD_PRECISION) / lpSupply;\r\n        }\r\n        pending = uint256(int256((user.amount * accRewardPerShare) / ACC_REWARD_PRECISION) - user.rewardDebt);\r\n    }\r\n\r\n    /// @notice Update reward variables of the given pool.\r\n    /// @param pid The index of the pool. See `poolInfo`.\r\n    /// @return pool Returns the pool that was updated.\r\n    function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\r\n        pool = poolInfo[pid];\r\n        if (block.timestamp > pool.lastRewardTime) {\r\n            uint256 lpSupply = lpToken[pid].balanceOf(address(this));\r\n            if (lpSupply > 0) {\r\n                uint256 time = block.timestamp - pool.lastRewardTime;\r\n                uint256 rewardAmount = (time * rewardPerSecond * pool.allocPoint) / totalAllocPoint;\r\n                pool.accRewardPerShare += (rewardAmount * ACC_REWARD_PRECISION) / lpSupply;\r\n            }\r\n            pool.lastRewardTime = block.timestamp;\r\n            poolInfo[pid] = pool;\r\n            emit LogUpdatePool(pid, pool.lastRewardTime, lpSupply, pool.accRewardPerShare);\r\n        }\r\n    }\r\n\r\n    /// @notice Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 len = poolInfo.length;\r\n        for (uint256 i = 0; i < len; ++i) {\r\n            updatePool(i);\r\n        }\r\n    }\r\n\r\n    /// @notice Deposit LP tokens to MCV2 for reward allocation.\r\n    /// @param pid The index of the pool. See `poolInfo`.\r\n    /// @param amount LP token amount to deposit.\r\n    /// @param to The receiver of `amount` deposit benefit.\r\n    function deposit(\r\n        uint256 pid,\r\n        uint256 amount,\r\n        address to\r\n    ) public {\r\n        PoolInfo memory pool = updatePool(pid);\r\n        UserInfo storage user = userInfo[pid][to];\r\n\r\n        // Effects\r\n        user.amount += amount;\r\n        user.rewardDebt += int256((amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION);\r\n\r\n        // Interactions\r\n        IRewarder _rewarder = rewarder[pid];\r\n        if (address(_rewarder) != address(0)) {\r\n            _rewarder.onReward(pid, to, to, 0, user.amount);\r\n        }\r\n\r\n        lpToken[pid].safeTransferFrom(msg.sender, address(this), amount);\r\n\r\n        emit Deposit(msg.sender, pid, amount, to);\r\n    }\r\n\r\n    /// @notice Withdraw LP tokens from MCV2.\r\n    /// @param pid The index of the pool. See `poolInfo`.\r\n    /// @param amount LP token amount to withdraw.\r\n    /// @param to Receiver of the LP tokens.\r\n    function withdraw(\r\n        uint256 pid,\r\n        uint256 amount,\r\n        address to\r\n    ) public {\r\n        PoolInfo memory pool = updatePool(pid);\r\n        UserInfo storage user = userInfo[pid][msg.sender];\r\n\r\n        // Effects\r\n        user.rewardDebt -= int256((amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION);\r\n        user.amount -= amount;\r\n\r\n        // Interactions\r\n        IRewarder _rewarder = rewarder[pid];\r\n        if (address(_rewarder) != address(0)) {\r\n            _rewarder.onReward(pid, msg.sender, to, 0, user.amount);\r\n        }\r\n\r\n        lpToken[pid].safeTransfer(to, amount);\r\n\r\n        emit Withdraw(msg.sender, pid, amount, to);\r\n    }\r\n\r\n    /// @notice Harvest proceeds for transaction sender to `to`.\r\n    /// @param pid The index of the pool. See `poolInfo`.\r\n    /// @param to Receiver of rewards.\r\n    function harvest(uint256 pid, address to) public {\r\n        PoolInfo memory pool = updatePool(pid);\r\n        UserInfo storage user = userInfo[pid][msg.sender];\r\n        int256 accumulatedReward = int256((user.amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION);\r\n        uint256 _pendingReward = uint256(accumulatedReward - user.rewardDebt);\r\n\r\n        // Effects\r\n        user.rewardDebt = accumulatedReward;\r\n\r\n        // Interactions\r\n        if (_pendingReward != 0) {\r\n            rewardMinter.mint(to, _pendingReward);\r\n        }\r\n\r\n        IRewarder _rewarder = rewarder[pid];\r\n        if (address(_rewarder) != address(0)) {\r\n            _rewarder.onReward(pid, msg.sender, to, _pendingReward, user.amount);\r\n        }\r\n\r\n        emit Harvest(msg.sender, pid, _pendingReward);\r\n    }\r\n\r\n    /// @notice Withdraw LP tokens from MCV2 and harvest proceeds for transaction sender to `to`.\r\n    /// @param pid The index of the pool. See `poolInfo`.\r\n    /// @param amount LP token amount to withdraw.\r\n    /// @param to Receiver of the LP tokens and rewards.\r\n    function withdrawAndHarvest(\r\n        uint256 pid,\r\n        uint256 amount,\r\n        address to\r\n    ) public {\r\n        PoolInfo memory pool = updatePool(pid);\r\n        UserInfo storage user = userInfo[pid][msg.sender];\r\n        int256 accumulatedReward = int256((user.amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION);\r\n        uint256 _pendingReward = uint256(accumulatedReward - user.rewardDebt);\r\n\r\n        // Effects\r\n        user.rewardDebt = accumulatedReward - int256((amount * pool.accRewardPerShare) / ACC_REWARD_PRECISION);\r\n        user.amount -= amount;\r\n\r\n        // Interactions\r\n        if (_pendingReward != 0) {\r\n            rewardMinter.mint(to, _pendingReward);\r\n        }\r\n\r\n        IRewarder _rewarder = rewarder[pid];\r\n        if (address(_rewarder) != address(0)) {\r\n            _rewarder.onReward(pid, msg.sender, to, _pendingReward, user.amount);\r\n        }\r\n\r\n        lpToken[pid].safeTransfer(to, amount);\r\n\r\n        emit Withdraw(msg.sender, pid, amount, to);\r\n        emit Harvest(msg.sender, pid, _pendingReward);\r\n    }\r\n\r\n    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    /// @param pid The index of the pool. See `poolInfo`.\r\n    /// @param to Receiver of the LP tokens.\r\n    function emergencyWithdraw(uint256 pid, address to) public {\r\n        UserInfo storage user = userInfo[pid][msg.sender];\r\n        uint256 amount = user.amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n\r\n        IRewarder _rewarder = rewarder[pid];\r\n        if (address(_rewarder) != address(0)) {\r\n            _rewarder.onReward(pid, msg.sender, to, 0, 0);\r\n        }\r\n\r\n        // Note: transfer can fail or succeed if `amount` is zero.\r\n        lpToken[pid].safeTransfer(to, amount);\r\n        emit EmergencyWithdraw(msg.sender, pid, amount, to);\r\n    }\r\n\r\n    function harvestAllRewards(address to) external {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            harvest(pid, to);\r\n        }\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function checkPoolDuplicate(IERC20 _lpToken) internal view {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            require(lpToken[pid] != _lpToken, \"add: existing pool?\");\r\n        }\r\n    }\r\n\r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n\r\n    /// @notice Add a new LP to the pool. Can only be called by the owner.\r\n    /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\r\n    /// @param allocPoint AP of the new pool.\r\n    /// @param _lpToken Address of the LP ERC-20 token.\r\n    /// @param _rewarder Address of the rewarder delegate.\r\n    function add(\r\n        uint256 allocPoint,\r\n        IERC20 _lpToken,\r\n        IRewarder _rewarder\r\n    ) public onlyOwner {\r\n        checkPoolDuplicate(_lpToken);\r\n        massUpdatePools();\r\n        totalAllocPoint += allocPoint;\r\n        lpToken.push(_lpToken);\r\n        rewarder.push(_rewarder);\r\n\r\n        poolInfo.push(PoolInfo({allocPoint: allocPoint, lastRewardTime: block.timestamp, accRewardPerShare: 0}));\r\n        require(poolInfo.length <= MAX_NUM_OF_POOLS, \"WonderfulChef::add: > MAX_NUM_OF_POOLS\");\r\n        emit LogPoolAddition(lpToken.length - 1, allocPoint, _lpToken, _rewarder);\r\n    }\r\n\r\n    /// @notice Update the given pool's reward allocation point and `IRewarder` contract. Can only be called by the owner.\r\n    /// @param _pid The index of the pool. See `poolInfo`.\r\n    /// @param _allocPoint New AP of the pool.\r\n    /// @param _rewarder Address of the rewarder delegate.\r\n    /// @param overwrite True if _rewarder should be `set`. Otherwise `_rewarder` is ignored.\r\n    function set(\r\n        uint256 _pid,\r\n        uint256 _allocPoint,\r\n        IRewarder _rewarder,\r\n        bool overwrite\r\n    ) public onlyOwner {\r\n        massUpdatePools();\r\n        totalAllocPoint = totalAllocPoint - poolInfo[_pid].allocPoint + _allocPoint;\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n        if (overwrite) {\r\n            rewarder[_pid] = _rewarder;\r\n        }\r\n        emit LogSetPool(_pid, _allocPoint, overwrite ? _rewarder : rewarder[_pid], overwrite);\r\n    }\r\n\r\n    /// @notice Sets the reward per second to be distributed. Can only be called by the owner.\r\n    /// @param _rewardPerSecond The amount of reward to be distributed per second.\r\n    function setRewardPerSecond(uint256 _rewardPerSecond) public onlyOwner {\r\n        require(_rewardPerSecond <= MAX_REWARD_PER_SECOND, \"WonderfulChef::setRewardPerSecond: > MAX_REWARD_PER_SECOND\");\r\n        massUpdatePools();\r\n        rewardPerSecond = _rewardPerSecond;\r\n        emit LogRewardPerSecond(_rewardPerSecond);\r\n    }\r\n\r\n    /// @notice Set the address of rewardMinter.  Can only be called ONCE by the owner.\r\n    /// @param _rewardMinter Address of MultiFeeDistribution contract\r\n    function setRewardMinter(IWonderfulStaking _rewardMinter) external {\r\n        require(address(rewardMinter) == address(0), \"WonderfulChef::setRewardMinter: Cannot redefine rewardMinter\");\r\n        rewardMinter = _rewardMinter;\r\n    }\r\n\r\n    /* =============== EVENTS ==================== */\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\r\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount, address indexed to);\r\n    event Harvest(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event LogPoolAddition(uint256 indexed pid, uint256 allocPoint, IERC20 indexed lpToken, IRewarder indexed rewarder);\r\n    event LogSetPool(uint256 indexed pid, uint256 allocPoint, IRewarder indexed rewarder, bool overwrite);\r\n    event LogUpdatePool(uint256 indexed pid, uint256 lastRewardTime, uint256 lpSupply, uint256 accRewardPerShare);\r\n    event LogRewardPerSecond(uint256 rewardPerSecond);\r\n}\r\n"
    },
    "contracts/farms/WonderfulStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"../interfaces/IYToken.sol\";\r\nimport \"../interfaces/IYTokenReserve.sol\";\r\nimport \"../libs/WethUtils.sol\";\r\n\r\n// Based on EPS's & Geist's MultiFeeDistribution\r\ncontract WonderfulStaking is ReentrancyGuard, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using SafeERC20 for IYToken;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    struct Reward {\r\n        uint256 periodFinish;\r\n        uint256 rewardRate;\r\n        uint256 lastUpdateTime;\r\n        uint256 rewardPerTokenStored;\r\n    }\r\n    struct Balances {\r\n        uint256 total;\r\n        uint256 unlocked;\r\n        uint256 locked;\r\n        uint256 earned;\r\n    }\r\n    struct LockedBalance {\r\n        uint256 amount;\r\n        uint256 unlockTime;\r\n    }\r\n    struct RewardData {\r\n        address token;\r\n        uint256 amount;\r\n    }\r\n\r\n    IYToken public stakingToken;\r\n    IYTokenReserve public stakingTokenReserve;\r\n    address[] public rewardTokens;\r\n    mapping(address => Reward) public rewardData;\r\n\r\n    // Duration that rewards are streamed over\r\n    uint256 public constant rewardsDuration = 86400 * 7; // 1 weeks\r\n\r\n    // Duration of lock/earned penalty period\r\n    uint256 public constant lockDuration = rewardsDuration * 4; // 4 weeks\r\n\r\n    // Addresses approved to call mint\r\n    mapping(address => bool) public minters;\r\n    address[] public mintersArray;\r\n\r\n    // reward token -> distributor -> is approved to add rewards\r\n    mapping(address => mapping(address => bool)) public rewardDistributors;\r\n\r\n    // user -> reward token -> amount\r\n    mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\r\n    mapping(address => mapping(address => uint256)) public rewards;\r\n\r\n    uint256 public totalSupply;\r\n    uint256 public lockedSupply;\r\n\r\n    // Private mappings for balance data\r\n    mapping(address => Balances) private balances;\r\n    mapping(address => LockedBalance[]) private userLocks;\r\n    mapping(address => LockedBalance[]) private userEarnings;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        address _stakingToken,\r\n        address _stakingTokenReserve,\r\n        address[] memory _minters\r\n    ) Ownable() {\r\n        stakingToken = IYToken(_stakingToken);\r\n        stakingTokenReserve = IYTokenReserve(_stakingTokenReserve);\r\n        stakingTokenReserve.setRewarder(address(this));\r\n        for (uint256 i; i < _minters.length; i++) {\r\n            minters[_minters[i]] = true;\r\n            mintersArray.push(_minters[i]);\r\n        }\r\n        // First reward MUST be the staking token or things will break\r\n        // related to the 50% penalty and distribution to locked balances\r\n        rewardTokens.push(_stakingToken);\r\n        rewardData[_stakingToken].lastUpdateTime = block.timestamp;\r\n        rewardData[_stakingToken].periodFinish = block.timestamp;\r\n    }\r\n\r\n    /* ========== ADMIN CONFIGURATION ========== */\r\n\r\n    // Add a new reward token to be distributed to stakers\r\n    function addReward(address _rewardsToken, address _distributor) public onlyOwner {\r\n        require(rewardData[_rewardsToken].lastUpdateTime == 0, \"MultiFeeDistribution::addReward: Invalid\");\r\n        rewardTokens.push(_rewardsToken);\r\n        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\r\n        rewardData[_rewardsToken].periodFinish = block.timestamp;\r\n        rewardDistributors[_rewardsToken][_distributor] = true;\r\n        emit RewardTokenAdded(_rewardsToken);\r\n        emit RewardDistributorApproved(_rewardsToken, _distributor, true);\r\n    }\r\n\r\n    // Modify approval for an address to call notifyRewardAmount\r\n    function approveRewardDistributor(\r\n        address _rewardsToken,\r\n        address _distributor,\r\n        bool _approved\r\n    ) external onlyOwner {\r\n        require(rewardData[_rewardsToken].lastUpdateTime > 0, \"MultiFeeDistribution::approveRewardDistributor: Invalid\");\r\n        rewardDistributors[_rewardsToken][_distributor] = _approved;\r\n        emit RewardDistributorApproved(_rewardsToken, _distributor, _approved);\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function _rewardPerToken(address _rewardsToken, uint256 _supply) internal view returns (uint256) {\r\n        if (_supply == 0) {\r\n            return rewardData[_rewardsToken].rewardPerTokenStored;\r\n        }\r\n        return\r\n            rewardData[_rewardsToken].rewardPerTokenStored.add(\r\n                lastTimeRewardApplicable(_rewardsToken).sub(rewardData[_rewardsToken].lastUpdateTime).mul(rewardData[_rewardsToken].rewardRate).mul(1e18).div(_supply)\r\n            );\r\n    }\r\n\r\n    function _earned(\r\n        address _user,\r\n        address _rewardsToken,\r\n        uint256 _balance,\r\n        uint256 supply\r\n    ) internal view returns (uint256) {\r\n        return _balance.mul(_rewardPerToken(_rewardsToken, supply).sub(userRewardPerTokenPaid[_user][_rewardsToken])).div(1e18).add(rewards[_user][_rewardsToken]);\r\n    }\r\n\r\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256) {\r\n        return Math.min(block.timestamp, rewardData[_rewardsToken].periodFinish);\r\n    }\r\n\r\n    function rewardPerToken(address _rewardsToken) external view returns (uint256) {\r\n        uint256 supply = _rewardsToken == address(stakingToken) ? lockedSupply : totalSupply;\r\n        return _rewardPerToken(_rewardsToken, supply);\r\n    }\r\n\r\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256) {\r\n        return rewardData[_rewardsToken].rewardRate.mul(rewardsDuration);\r\n    }\r\n\r\n    // Address and claimable amount of all reward tokens for the given account\r\n    function claimableRewards(address account) external view returns (RewardData[] memory _rewards) {\r\n        _rewards = new RewardData[](rewardTokens.length);\r\n        for (uint256 i = 0; i < _rewards.length; i++) {\r\n            // If i == 0 this is the stakingReward, distribution is based on locked balances\r\n            uint256 balance = i == 0 ? balances[account].locked : balances[account].total;\r\n            uint256 supply = i == 0 ? lockedSupply : totalSupply;\r\n            _rewards[i].token = rewardTokens[i];\r\n            _rewards[i].amount = _earned(account, _rewards[i].token, balance, supply);\r\n        }\r\n        return _rewards;\r\n    }\r\n\r\n    // Total balance of an account, including unlocked, locked and earned tokens\r\n    function totalBalance(address user) external view returns (uint256 amount) {\r\n        return balances[user].total;\r\n    }\r\n\r\n    // Total withdrawable balance for an account to which no penalty is applied\r\n    function unlockedBalance(address user) external view returns (uint256 amount) {\r\n        amount = balances[user].unlocked;\r\n        LockedBalance[] storage earnings = userEarnings[msg.sender];\r\n        for (uint256 i = 0; i < earnings.length; i++) {\r\n            if (earnings[i].unlockTime > block.timestamp) {\r\n                break;\r\n            }\r\n            amount = amount.add(earnings[i].amount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    // Information on the \"earned\" balances of a user\r\n    // Earned balances may be withdrawn immediately for a 50% penalty\r\n    function earnedBalances(address user) external view returns (uint256 total, LockedBalance[] memory earningsData) {\r\n        LockedBalance[] storage earnings = userEarnings[user];\r\n        uint256 idx;\r\n        for (uint256 i = 0; i < earnings.length; i++) {\r\n            if (earnings[i].unlockTime > block.timestamp) {\r\n                if (idx == 0) {\r\n                    earningsData = new LockedBalance[](earnings.length - i);\r\n                }\r\n                earningsData[idx] = earnings[i];\r\n                idx++;\r\n                total = total.add(earnings[i].amount);\r\n            }\r\n        }\r\n        return (total, earningsData);\r\n    }\r\n\r\n    // Information on a user's locked balances\r\n    function lockedBalances(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 total,\r\n            uint256 unlockable,\r\n            uint256 locked,\r\n            LockedBalance[] memory lockData\r\n        )\r\n    {\r\n        LockedBalance[] storage locks = userLocks[user];\r\n        uint256 idx;\r\n        for (uint256 i = 0; i < locks.length; i++) {\r\n            if (locks[i].unlockTime > block.timestamp) {\r\n                if (idx == 0) {\r\n                    lockData = new LockedBalance[](locks.length - i);\r\n                }\r\n                lockData[idx] = locks[i];\r\n                idx++;\r\n                locked = locked.add(locks[i].amount);\r\n            } else {\r\n                unlockable = unlockable.add(locks[i].amount);\r\n            }\r\n        }\r\n        return (balances[user].locked, unlockable, locked, lockData);\r\n    }\r\n\r\n    // Final balance received and penalty balance paid by user upon calling exit\r\n    function withdrawableBalance(address user) public view returns (uint256 amount, uint256 penaltyAmount) {\r\n        Balances storage bal = balances[user];\r\n        if (bal.earned > 0) {\r\n            uint256 amountWithoutPenalty;\r\n            uint256 length = userEarnings[user].length;\r\n            for (uint256 i = 0; i < length; i++) {\r\n                uint256 earnedAmount = userEarnings[user][i].amount;\r\n                if (earnedAmount == 0) continue;\r\n                if (userEarnings[user][i].unlockTime > block.timestamp) {\r\n                    break;\r\n                }\r\n                amountWithoutPenalty = amountWithoutPenalty.add(earnedAmount);\r\n            }\r\n\r\n            penaltyAmount = bal.earned.sub(amountWithoutPenalty).div(2);\r\n        }\r\n        amount = bal.unlocked.add(bal.earned).sub(penaltyAmount);\r\n        return (amount, penaltyAmount);\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    // Stake tokens to receive rewards\r\n    // Locked tokens cannot be withdrawn for lockedStakingLockDuration and are eligible to receive stakingReward rewards\r\n    function stake(uint256 amount, bool lock) external nonReentrant updateReward(msg.sender) {\r\n        require(amount > 0, \"MultiFeeDistribution::stake: Cannot stake 0\");\r\n        totalSupply = totalSupply.add(amount);\r\n        Balances storage bal = balances[msg.sender];\r\n        bal.total = bal.total.add(amount);\r\n        if (lock) {\r\n            lockedSupply = lockedSupply.add(amount);\r\n            bal.locked = bal.locked.add(amount);\r\n            uint256 unlockTime = block.timestamp.div(rewardsDuration).mul(rewardsDuration).add(lockDuration);\r\n            uint256 idx = userLocks[msg.sender].length;\r\n            if (idx == 0 || userLocks[msg.sender][idx - 1].unlockTime < unlockTime) {\r\n                userLocks[msg.sender].push(LockedBalance({amount: amount, unlockTime: unlockTime}));\r\n            } else {\r\n                userLocks[msg.sender][idx - 1].amount = userLocks[msg.sender][idx - 1].amount.add(amount);\r\n            }\r\n        } else {\r\n            bal.unlocked = bal.unlocked.add(amount);\r\n        }\r\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\r\n        emit Staked(msg.sender, amount);\r\n    }\r\n\r\n    // Mint new tokens\r\n    // Minted tokens receive rewards normally but incur a 50% penalty when\r\n    // withdrawn before rewardsLockDuration has passed.\r\n    function mint(address user, uint256 amount) external updateReward(user) {\r\n        require(minters[msg.sender], \"MultiFeeDistribution::mint: Only minters allowed\");\r\n        totalSupply = totalSupply.add(amount);\r\n        Balances storage bal = balances[user];\r\n        bal.total = bal.total.add(amount);\r\n        bal.earned = bal.earned.add(amount);\r\n        uint256 unlockTime = block.timestamp.div(rewardsDuration).mul(rewardsDuration).add(lockDuration);\r\n        LockedBalance[] storage earnings = userEarnings[user];\r\n        uint256 idx = earnings.length;\r\n\r\n        if (idx == 0 || earnings[idx - 1].unlockTime < unlockTime) {\r\n            earnings.push(LockedBalance({amount: amount, unlockTime: unlockTime}));\r\n        } else {\r\n            earnings[idx - 1].amount = earnings[idx - 1].amount.add(amount);\r\n        }\r\n        stakingTokenReserve.transfer(address(this), amount);\r\n        emit Staked(user, amount);\r\n    }\r\n\r\n    // Withdraw staked tokens\r\n    // First withdraws unlocked tokens, then earned tokens. Withdrawing earned tokens\r\n    // incurs a 50% penalty which is distributed based on locked balances.\r\n    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\r\n        require(amount > 0, \"MultiFeeDistribution::withdraw: Cannot withdraw 0\");\r\n        Balances storage bal = balances[msg.sender];\r\n        uint256 penaltyAmount;\r\n\r\n        if (amount <= bal.unlocked) {\r\n            bal.unlocked = bal.unlocked.sub(amount);\r\n        } else {\r\n            uint256 remaining = amount.sub(bal.unlocked);\r\n            require(bal.earned >= remaining, \"MultiFeeDistribution::withdraw: Insufficient unlocked balance\");\r\n            bal.unlocked = 0;\r\n            bal.earned = bal.earned.sub(remaining);\r\n            for (uint256 i = 0; ; i++) {\r\n                uint256 earnedAmount = userEarnings[msg.sender][i].amount;\r\n                if (earnedAmount == 0) continue;\r\n                if (penaltyAmount == 0 && userEarnings[msg.sender][i].unlockTime > block.timestamp) {\r\n                    penaltyAmount = remaining;\r\n                    require(bal.earned >= remaining, \"MultiFeeDistribution::withdraw: Insufficient balance after penalty\");\r\n                    bal.earned = bal.earned.sub(remaining);\r\n                    if (bal.earned == 0) {\r\n                        delete userEarnings[msg.sender];\r\n                        break;\r\n                    }\r\n                    remaining = remaining.mul(2);\r\n                }\r\n                if (remaining <= earnedAmount) {\r\n                    userEarnings[msg.sender][i].amount = earnedAmount.sub(remaining);\r\n                    break;\r\n                } else {\r\n                    delete userEarnings[msg.sender][i];\r\n                    remaining = remaining.sub(earnedAmount);\r\n                }\r\n            }\r\n        }\r\n\r\n        uint256 adjustedAmount = amount.add(penaltyAmount);\r\n        bal.total = bal.total.sub(adjustedAmount);\r\n        totalSupply = totalSupply.sub(adjustedAmount);\r\n        stakingToken.safeTransfer(msg.sender, amount);\r\n        if (penaltyAmount > 0) {\r\n            _notifyReward(address(stakingToken), penaltyAmount);\r\n        }\r\n        emit Withdrawn(msg.sender, amount);\r\n    }\r\n\r\n    // Claim all pending staking rewards\r\n    function getReward() public nonReentrant updateReward(msg.sender) {\r\n        for (uint256 i; i < rewardTokens.length; i++) {\r\n            address _rewardToken = rewardTokens[i];\r\n            uint256 reward = rewards[msg.sender][_rewardToken];\r\n            if (reward > 0) {\r\n                rewards[msg.sender][_rewardToken] = 0;\r\n                if (WethUtils.isWeth(_rewardToken)) {\r\n                    WethUtils.unwrap(reward);\r\n                    Address.sendValue(payable(msg.sender), reward);\r\n                } else {\r\n                    IERC20(_rewardToken).safeTransfer(msg.sender, reward);\r\n                }\r\n                emit RewardPaid(msg.sender, _rewardToken, reward);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Withdraw full unlocked balance and claim pending rewards\r\n    function emergencyWithdraw() external updateReward(msg.sender) {\r\n        (uint256 amount, uint256 penaltyAmount) = withdrawableBalance(msg.sender);\r\n        delete userEarnings[msg.sender];\r\n        Balances storage bal = balances[msg.sender];\r\n        bal.total = bal.total.sub(bal.unlocked).sub(bal.earned);\r\n        bal.unlocked = 0;\r\n        bal.earned = 0;\r\n\r\n        totalSupply = totalSupply.sub(amount.add(penaltyAmount));\r\n        stakingToken.safeTransfer(msg.sender, amount);\r\n        if (penaltyAmount > 0) {\r\n            _notifyReward(address(stakingToken), penaltyAmount);\r\n        }\r\n        getReward();\r\n    }\r\n\r\n    // Withdraw all currently locked tokens where the unlock time has passed\r\n    function withdrawExpiredLocks() external {\r\n        LockedBalance[] storage locks = userLocks[msg.sender];\r\n        Balances storage bal = balances[msg.sender];\r\n        uint256 amount;\r\n        uint256 length = locks.length;\r\n        if (locks[length - 1].unlockTime <= block.timestamp) {\r\n            amount = bal.locked;\r\n            delete userLocks[msg.sender];\r\n        } else {\r\n            for (uint256 i = 0; i < length; i++) {\r\n                if (locks[i].unlockTime > block.timestamp) break;\r\n                amount = amount.add(locks[i].amount);\r\n                delete locks[i];\r\n            }\r\n        }\r\n        bal.locked = bal.locked.sub(amount);\r\n        bal.total = bal.total.sub(amount);\r\n        totalSupply = totalSupply.sub(amount);\r\n        lockedSupply = lockedSupply.sub(amount);\r\n        stakingToken.safeTransfer(msg.sender, amount);\r\n    }\r\n\r\n\r\n\r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n\r\n    function _notifyReward(address _rewardsToken, uint256 reward) internal {\r\n        if (block.timestamp >= rewardData[_rewardsToken].periodFinish) {\r\n            rewardData[_rewardsToken].rewardRate = reward.div(rewardsDuration);\r\n        } else {\r\n            uint256 remaining = rewardData[_rewardsToken].periodFinish.sub(block.timestamp);\r\n            uint256 leftover = remaining.mul(rewardData[_rewardsToken].rewardRate);\r\n            rewardData[_rewardsToken].rewardRate = reward.add(leftover).div(rewardsDuration);\r\n        }\r\n\r\n        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\r\n        rewardData[_rewardsToken].periodFinish = block.timestamp.add(rewardsDuration);\r\n    }\r\n\r\n    function notifyRewardAmount(address _rewardsToken, uint256 reward) external updateReward(address(0)) {\r\n        require(rewardDistributors[_rewardsToken][msg.sender], \"MultiFeeDistribution::notifyRewardAmount: Only reward distributors allowed\");\r\n        require(reward > 0, \"MultiFeeDistribution::notifyRewardAmount: No reward\");\r\n        // handle the transfer of reward tokens via `transferFrom` to reduce the number\r\n        // of transactions required and ensure correctness of the reward amount\r\n        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), reward);\r\n        _notifyReward(_rewardsToken, reward);\r\n        emit RewardAdded(reward);\r\n    }\r\n\r\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\r\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\r\n        require(tokenAddress != address(stakingToken), \"MultiFeeDistribution::recoverERC20: Cannot withdraw staking token\");\r\n        require(rewardData[tokenAddress].lastUpdateTime == 0, \"MultiFeeDistribution::recoverERC20: Cannot withdraw reward token\");\r\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\r\n        emit Recovered(tokenAddress, tokenAmount);\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier updateReward(address account) {\r\n        address token = address(stakingToken);\r\n        uint256 balance;\r\n        uint256 supply = lockedSupply;\r\n        rewardData[token].rewardPerTokenStored = _rewardPerToken(token, supply);\r\n        rewardData[token].lastUpdateTime = lastTimeRewardApplicable(token);\r\n        if (account != address(0)) {\r\n            // Special case, use the locked balances and supply for stakingReward rewards\r\n            rewards[account][token] = _earned(account, token, balances[account].locked, supply);\r\n            userRewardPerTokenPaid[account][token] = rewardData[token].rewardPerTokenStored;\r\n            balance = balances[account].total;\r\n        }\r\n\r\n        supply = totalSupply;\r\n        for (uint256 i = 1; i < rewardTokens.length; i++) {\r\n            token = rewardTokens[i];\r\n            rewardData[token].rewardPerTokenStored = _rewardPerToken(token, supply);\r\n            rewardData[token].lastUpdateTime = lastTimeRewardApplicable(token);\r\n            if (account != address(0)) {\r\n                rewards[account][token] = _earned(account, token, balance, supply);\r\n                userRewardPerTokenPaid[account][token] = rewardData[token].rewardPerTokenStored;\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @notice fallback for payable -> required to unwrap WETH\r\n    receive() external payable {}\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event RewardAdded(uint256 reward);\r\n    event RewardTokenAdded(address indexed rewardTokenAddress);\r\n    event RewardDistributorApproved(address indexed rewardAddress, address indexed distributor, bool approved);\r\n    event Staked(address indexed user, uint256 amount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event RewardPaid(address indexed user, address indexed rewardsToken, uint256 reward);\r\n    event Recovered(address token, uint256 amount);\r\n}\r\n"
    },
    "contracts/funds/AFXAirdropFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"./Fund.sol\";\r\n\r\ncontract AFXAirdropFund is Fund {\r\n    uint256 public constant ALLOCATION = 300_000 ether; // 1%\r\n    uint256 public constant VESTING_DURATION = 3 * 24 * 3600; // 3 days)\r\n    uint256 public constant VESTING_START = 1675555200; // Sun Feb 05 2023 00:00:00 GMT+0000\r\n\r\n    /*===================== VIEWS =====================*/\r\n\r\n    function allocation() public pure override returns (uint256) {\r\n        return ALLOCATION;\r\n    }\r\n\r\n    function vestingStart() public pure override returns (uint256) {\r\n        return VESTING_START;\r\n    }\r\n\r\n    function vestingDuration() public pure override returns (uint256) {\r\n        return VESTING_DURATION;\r\n    }\r\n}\r\n"
    },
    "contracts/funds/AFXDaoFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"./Fund.sol\";\r\n\r\ncontract AFXDaoFund is Fund {\r\n    uint256 public constant ALLOCATION = 3_000_000 ether; // 10%\r\n    uint256 public constant VESTING_DURATION = 3 * 365 * 24 * 3600; // 3 years\r\n    uint256 public constant VESTING_START = 1676764800; // Sun Feb 19 2023 00:00:00 GMT+0000\r\n\r\n    /*===================== VIEWS =====================*/\r\n\r\n    function allocation() public pure override returns (uint256) {\r\n        return ALLOCATION;\r\n    }\r\n\r\n    function vestingStart() public pure override returns (uint256) {\r\n        return VESTING_START;\r\n    }\r\n\r\n    function vestingDuration() public pure override returns (uint256) {\r\n        return VESTING_DURATION;\r\n    }\r\n}\r\n"
    },
    "contracts/funds/AFXDevFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"./Fund.sol\";\r\n\r\ncontract AFXDevFund is Fund {\r\n    uint256 public constant ALLOCATION = 3_000_000 ether; // 10%\r\n    uint256 public constant VESTING_DURATION = 3 * 365 * 24 * 3600; // 3 years\r\n    uint256 public constant VESTING_START = 1676764800; // Sun Feb 19 2023 00:00:00 GMT+0000\r\n\r\n    /*===================== VIEWS =====================*/\r\n\r\n    function allocation() public pure override returns (uint256) {\r\n        return ALLOCATION;\r\n    }\r\n\r\n    function vestingStart() public pure override returns (uint256) {\r\n        return VESTING_START;\r\n    }\r\n\r\n    function vestingDuration() public pure override returns (uint256) {\r\n        return VESTING_DURATION;\r\n    }\r\n}\r\n"
    },
    "contracts/funds/AFXReserve.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\ncontract AFXReserve is Initializable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 public afx;\r\n\r\n    address public rewarder;\r\n    address public pool;\r\n\r\n    /* ============ CONSTRUCTORS ========== */\r\n\r\n    function initialize(address _afx) external initializer {\r\n        require(_afx != address(0), \"AfxReserve::constructor: invalid address\");\r\n        afx = IERC20(_afx);\r\n    }\r\n\r\n    /* ============ MUTATIVE ========== */\r\n\r\n    function setRewarder(address _rewarder) external returns (bool) {\r\n        require(rewarder == address(0), \"AfxReserve::setRewarder: NOT_ALLOWED\");\r\n        rewarder = _rewarder;\r\n        return true;\r\n    }\r\n\r\n    function setPool(address _pool) external returns (bool) {\r\n        require(pool == address(0), \"AfxReserve::setPool: NOT_ALLOWED\");\r\n        pool = _pool;\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _amount) external {\r\n        require(rewarder == msg.sender || pool == msg.sender, \"AfxReserve::transfer: Only allowed funds can withdraw\");\r\n        require(_to != address(0), \"AfxReserve::transfer: Invalid address\");\r\n        afx.safeTransfer(_to, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/funds/AFXTreasuryFund.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"./Fund.sol\";\r\n\r\ncontract AFXTreasuryFund is Fund {\r\n    uint256 public constant ALLOCATION = 2_700_000 ether; // 9%\r\n    uint256 public constant VESTING_DURATION = 3 * 365 * 24 * 3600; // 3 years\r\n    uint256 public constant VESTING_START = 1676764800; // Sun Feb 19 2023 00:00:00 GMT+0000\r\n\r\n    /*===================== VIEWS =====================*/\r\n\r\n    function allocation() public pure override returns (uint256) {\r\n        return ALLOCATION;\r\n    }\r\n\r\n    function vestingStart() public pure override returns (uint256) {\r\n        return VESTING_START;\r\n    }\r\n\r\n    function vestingDuration() public pure override returns (uint256) {\r\n        return VESTING_DURATION;\r\n    }\r\n}\r\n"
    },
    "contracts/funds/Fund.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nabstract contract Fund is Ownable, Initializable {\r\n    using SafeERC20 for IERC20;\r\n    IERC20 public afx;\r\n    uint256 public claimedAmount;\r\n\r\n    /*===================== CONSTRUCTOR =====================*/\r\n\r\n    function initialize(address _afx) external initializer {\r\n        require(_afx != address(0), \"Fund::constructor: Invalid address\");\r\n        afx = IERC20(_afx);\r\n    }\r\n\r\n    /*===================== VIEWS =====================*/\r\n\r\n    function allocation() public view virtual returns (uint256);\r\n\r\n    function vestingStart() public view virtual returns (uint256);\r\n\r\n    function vestingDuration() public view virtual returns (uint256);\r\n\r\n    function currentBalance() public view returns (uint256) {\r\n        return afx.balanceOf(address(this));\r\n    }\r\n\r\n    function vestedBalance() public view returns (uint256) {\r\n        uint256 _allocation = allocation();\r\n        uint256 _start = vestingStart();\r\n        uint256 _duration = vestingDuration();\r\n        if (block.timestamp <= _start) {\r\n            return 0;\r\n        }\r\n        if (block.timestamp > _start + _duration) {\r\n            return _allocation;\r\n        }\r\n        return (_allocation * (block.timestamp - _start)) / _duration;\r\n    }\r\n\r\n    function claimable() public view returns (uint256) {\r\n        return vestedBalance() - claimedAmount;\r\n    }\r\n\r\n    /*===================== MUTATIVE =====================*/\r\n    function transfer(address receiver, uint256 amount) external onlyOwner {\r\n        require(receiver != address(0), \"Fund::transfer: Invalid address\");\r\n        require(amount > 0, \"Fund::transfer: Invalid amount\");\r\n        require(amount <= claimable(), \"Fund::transfer: > vestedAmount\");\r\n\r\n        claimedAmount = claimedAmount + amount;\r\n        afx.safeTransfer(receiver, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IMasterOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IMasterOracle {\r\n    function getXTokenPrice() external view returns (uint256);\r\n\r\n    function getYTokenPrice() external view returns (uint256);\r\n\r\n    function getYTokenTWAP() external view returns (uint256);\r\n\r\n    function getXTokenTWAP() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/interfaces/IPairOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IPairOracle {\r\n    function twap(address token, uint256 pricePrecision) external view returns (uint256 amountOut);\r\n\r\n    function spot(address token, uint256 pricePrecision) external view returns (uint256 amountOut);\r\n\r\n    function update() external;\r\n}\r\n"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IPool {\r\n    function setTreasury(address _addr) external;\r\n\r\n    function recollateralize() external payable;\r\n}\r\n"
    },
    "contracts/interfaces/IRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IRewarder {\r\n    function onReward(\r\n        uint256 pid,\r\n        address user,\r\n        address recipient,\r\n        uint256 rewardAmount,\r\n        uint256 newLpAmount\r\n    ) external;\r\n\r\n    function pendingTokens(\r\n        uint256 pid,\r\n        address user,\r\n        uint256 rewardAmount\r\n    ) external view returns (IERC20[] memory, uint256[] memory);\r\n}\r\n"
    },
    "contracts/interfaces/ISwapStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface ISwapStrategy {\r\n    function execute(uint256 _wethIn, uint256 _yTokenOut) external;\r\n}\r\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IWETH is IERC20 {\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n}\r\n"
    },
    "contracts/interfaces/IWonderfulChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IWonderfulChef {\r\n    function lpToken(uint256 pid) external view returns (IERC20);\r\n\r\n    function deposit(\r\n        uint256 pid,\r\n        uint256 amount,\r\n        address to\r\n    ) external;\r\n}"
    },
    "contracts/interfaces/IWonderfulStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IWonderfulStaking {\r\n    function addReward(address rewardsToken, address distributor) external;\r\n\r\n    function mint(address user, uint256 amount) external;\r\n\r\n    function notifyRewardAmount(address rewardsToken, uint256 reward) external;\r\n}\r\n"
    },
    "contracts/interfaces/IWonderfulTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IWonderfulTreasury {\r\n    function balanceOf(address _token) external view returns (uint256);\r\n\r\n    function requestFund(address _token, uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/interfaces/IXToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IXToken is IERC20 {\r\n    function burnFrom(address account, uint256 amount) external;\r\n\r\n    function burn(uint256 _amount) external;\r\n\r\n    function mint(address _address, uint256 _amount) external;\r\n\r\n    function setMinter(address _minter) external;\r\n}\r\n"
    },
    "contracts/interfaces/IYToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\ninterface IYToken is IERC20 {\r\n    function burn(uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/interfaces/IYTokenReserve.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\ninterface IYTokenReserve {\r\n    function transfer(address _address, uint256 _amount) external;\r\n\r\n    function setRewarder(address _rewarder) external returns (bool);\r\n\r\n    function setPool(address _pool) external returns (bool);\r\n}\r\n"
    },
    "contracts/libs/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\n// computes square roots using the babylonian method\r\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\r\nlibrary Babylonian {\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n        // else z = 0\r\n    }\r\n}\r\n"
    },
    "contracts/libs/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"./Babylonian.sol\";\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\nlibrary FixedPoint {\r\n    // range: [0, 2**112 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq112x112 {\r\n        uint224 _x;\r\n    }\r\n\r\n    // range: [0, 2**144 - 1]\r\n    // resolution: 1 / 2**112\r\n    struct uq144x112 {\r\n        uint256 _x;\r\n    }\r\n\r\n    uint8 private constant RESOLUTION = 112;\r\n    uint256 private constant Q112 = uint256(1) << RESOLUTION;\r\n    uint256 private constant Q224 = Q112 << RESOLUTION;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(x) << RESOLUTION);\r\n    }\r\n\r\n    // encodes a uint144 as a UQ144x112\r\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\r\n        return uq144x112(uint256(x) << RESOLUTION);\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\r\n        require(x != 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112(self._x / uint224(x));\r\n    }\r\n\r\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\r\n    // reverts on overflow\r\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\r\n        uint256 z;\r\n        require(y == 0 || (z = uint256(self._x) * y) / y == uint256(self._x), \"FixedPoint: MULTIPLICATION_OVERFLOW\");\r\n        return uq144x112(z);\r\n    }\r\n\r\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\r\n    // equivalent to encode(numerator).div(denominator)\r\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\r\n        require(denominator > 0, \"FixedPoint: DIV_BY_ZERO\");\r\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\r\n    }\r\n\r\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\r\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\r\n        return uint112(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\r\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\r\n        return uint144(self._x >> RESOLUTION);\r\n    }\r\n\r\n    // take the reciprocal of a UQ112x112\r\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        require(self._x != 0, \"FixedPoint: ZERO_RECIPROCAL\");\r\n        return uq112x112(uint224(Q224 / self._x));\r\n    }\r\n\r\n    // square root of a UQ112x112\r\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\r\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x)) << 56));\r\n    }\r\n}\r\n"
    },
    "contracts/libs/Multicall.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity 0.8.4;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n/// @title Multicall - Aggregate results from multiple read-only function calls\r\n/// @author Michael Elliot <mike@makerdao.com>\r\n/// @author Joshua Levine <joshua@makerdao.com>\r\n/// @author Nick Johnson <arachnid@notdot.net>\r\n\r\ncontract Multicall {\r\n  struct Call {\r\n    address target;\r\n    bytes callData;\r\n  }\r\n\r\n  function aggregate(Call[] memory calls)\r\n    public\r\n    returns (uint256 blockNumber, bytes[] memory returnData)\r\n  {\r\n    blockNumber = block.number;\r\n    returnData = new bytes[](calls.length);\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\r\n      require(success);\r\n      returnData[i] = ret;\r\n    }\r\n  }\r\n\r\n  // Helper functions\r\n  function getEthBalance(address addr) public view returns (uint256 balance) {\r\n    balance = addr.balance;\r\n  }\r\n\r\n  function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\r\n    blockHash = blockhash(blockNumber);\r\n  }\r\n\r\n  function getLastBlockHash() public view returns (bytes32 blockHash) {\r\n    blockHash = blockhash(block.number - 1);\r\n  }\r\n\r\n  function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\r\n    timestamp = block.timestamp;\r\n  }\r\n\r\n  function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\r\n    difficulty = block.difficulty;\r\n  }\r\n\r\n  function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\r\n    gaslimit = block.gaslimit;\r\n  }\r\n\r\n  function getCurrentBlockCoinbase() public view returns (address coinbase) {\r\n    coinbase = block.coinbase;\r\n  }\r\n}"
    },
    "contracts/libs/SafeMath.sol": {
      "content": "// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}"
    },
    "contracts/libs/UQ112x112.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\n\r\n// range: [0, 2**112 - 1]\r\n// resolution: 1 / 2**112\r\n\r\nlibrary UQ112x112 {\r\n    uint224 constant Q112 = 2**112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * Q112; // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}\r\n"
    },
    "contracts/libs/WethUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../interfaces/IWETH.sol\";\r\n\r\nlibrary WethUtils {\r\n    using SafeERC20 for IWETH;\r\n\r\n    IWETH public constant weth = IWETH(0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6); //WETH GOERLI\r\n\r\n    function isWeth(address token) internal pure returns (bool) {\r\n        return address(weth) == token;\r\n    }\r\n\r\n    function wrap(uint256 amount) internal {\r\n        weth.deposit{value: amount}();\r\n    }\r\n\r\n    function unwrap(uint256 amount) internal {\r\n        weth.withdraw(amount);\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) internal {\r\n        weth.safeTransfer(to, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract MockERC20 is ERC20 {\r\n    uint8 internal decimals_;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) ERC20(_name, _symbol) {\r\n        decimals_ = _decimals;\r\n    }\r\n\r\n    function mint(uint256 _amount) public {\r\n        _mint(msg.sender, _amount);\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return decimals_;\r\n    }\r\n}\r\n"
    },
    "contracts/mocks/MockTreasury.sol": {
      "content": "pragma solidity 0.8.4;\r\n\r\ncontract MockTreasury {\r\n    uint256 public maxXethSupply;\r\n    uint256 private redeemFee;\r\n    uint256 private mintingFee;\r\n    uint256 private cr;\r\n\r\n    function mock(\r\n        uint256 _maxXethSupply,\r\n        uint256 _cr,\r\n        uint256 _mintingFee,\r\n        uint256 _redeemFee\r\n    ) public {\r\n        maxXethSupply = _maxXethSupply;\r\n        redeemFee = _redeemFee;\r\n        mintingFee = _mintingFee;\r\n        cr = _cr;\r\n    }\r\n\r\n    function info()\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return (cr, mintingFee, redeemFee);\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/MasterOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../interfaces/IPairOracle.sol\";\r\n\r\ncontract MasterOracle is Ownable {\r\n    uint256 private constant PRICE_PRECISION = 1e18;\r\n\r\n    IPairOracle public oracleXToken;\r\n    IPairOracle public oracleYToken;\r\n\r\n    address public xToken;\r\n    address public yToken;\r\n\r\n    constructor(\r\n        address _xToken,\r\n        address _yToken,\r\n        address _oracleXToken,\r\n        address _oracleYToken\r\n    ) {\r\n        require(_xToken != address(0), \"Invalid address\");\r\n        require(_yToken != address(0), \"Invalid address\");\r\n        require(_oracleXToken != address(0), \"Invalid address\");\r\n        require(_oracleYToken != address(0), \"Invalid address\");\r\n        xToken = _xToken;\r\n        yToken = _yToken;\r\n        oracleXToken = IPairOracle(_oracleXToken);\r\n        oracleYToken = IPairOracle(_oracleYToken);\r\n    }\r\n\r\n    function getXTokenPrice() public view returns (uint256) {\r\n        return oracleXToken.spot(xToken, PRICE_PRECISION);\r\n    }\r\n\r\n    function getYTokenPrice() public view returns (uint256) {\r\n        return oracleYToken.spot(yToken, PRICE_PRECISION);\r\n    }\r\n\r\n    function getXTokenTWAP() public view returns (uint256) {\r\n        return oracleXToken.twap(xToken, PRICE_PRECISION);\r\n    }\r\n\r\n    function getYTokenTWAP() public view returns (uint256) {\r\n        return oracleYToken.twap(yToken, PRICE_PRECISION);\r\n    }\r\n}\r\n"
    },
    "contracts/oracles/UniswapPairOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\r\nimport \"../libs/FixedPoint.sol\";\r\nimport \"../libs/UQ112x112.sol\";\r\n\r\ncontract UniswapPairOracle is Ownable {\r\n    using FixedPoint for *;\r\n\r\n    uint256 public PERIOD = 3600; // 60-minute TWAP (Time-Weighted Average Price)\r\n    uint256 private constant MAXIMUM_PERIOD = 3600 * 48; // 48 hours\r\n    uint256 private constant MINIMUM_PERIOD = 60 * 10; // 10 minutes\r\n    uint256 private constant LENIENCY = 3600 * 12; // 12 hours\r\n\r\n    IUniswapV2Pair public immutable pair;\r\n    address public immutable token0;\r\n    address public immutable token1;\r\n\r\n    uint256 public price0CumulativeLast;\r\n    uint256 public price1CumulativeLast;\r\n    uint32 public blockTimestampLast;\r\n    FixedPoint.uq112x112 public price0Average;\r\n    FixedPoint.uq112x112 public price1Average;\r\n\r\n    constructor(address pairAddress) {\r\n        IUniswapV2Pair _pair = IUniswapV2Pair(pairAddress);\r\n        pair = _pair;\r\n        token0 = _pair.token0();\r\n        token1 = _pair.token1();\r\n        price0CumulativeLast = _pair.price0CumulativeLast(); // Fetch the current accumulated price value (1 / 0)\r\n        price1CumulativeLast = _pair.price1CumulativeLast(); // Fetch the current accumulated price value (0 / 1)\r\n        uint112 reserve0;\r\n        uint112 reserve1;\r\n        (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();\r\n        require(reserve0 != 0 && reserve1 != 0, \"PairOracle: NO_RESERVES\"); // Ensure that there's liquidity in the pair\r\n    }\r\n\r\n    function setPeriod(uint256 _period) external onlyOwner {\r\n        require(_period <= MAXIMUM_PERIOD, \"PairOracle::setPeriod: > MAXIMUM_PERIOD\");\r\n        require(_period >= MINIMUM_PERIOD, \"PairOracle::setPeriod: < MINIMUM_PERIOD\");\r\n        PERIOD = _period;\r\n        emit PeriodUpdated(_period);\r\n    }\r\n\r\n    function update() external {\r\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = currentCumulativePrices(address(pair));\r\n        unchecked {\r\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast; // Overflow is desired\r\n\r\n            // Ensure that at least one full period has passed since the last update\r\n            require(timeElapsed >= PERIOD, \"PairOracle: PERIOD_NOT_ELAPSED\");\r\n\r\n            // Overflow is desired, casting never truncates\r\n            // Cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\r\n            price0Average = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed));\r\n            price1Average = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed));\r\n            price0CumulativeLast = price0Cumulative;\r\n            price1CumulativeLast = price1Cumulative;\r\n            blockTimestampLast = blockTimestamp;\r\n        }\r\n    }\r\n\r\n    // Note this will always return 0 before update has been called successfully for the first time.\r\n    function twap(address token, uint256 pricePrecision) external view returns (uint256 amountOut) {\r\n        uint32 timeElapsed = currentBlockTimestamp() - blockTimestampLast;\r\n        require(timeElapsed <= PERIOD + LENIENCY, \"PairOracle::twap: Oracle was staled\");\r\n        if (token == token0) {\r\n            amountOut = price0Average.mul(pricePrecision).decode144();\r\n        } else {\r\n            require(token == token1, \"PairOracle: INVALID_TOKEN\");\r\n            amountOut = price1Average.mul(pricePrecision).decode144();\r\n        }\r\n    }\r\n\r\n    function spot(address token, uint256 pricePrecision) external view returns (uint256 amountOut) {\r\n        IUniswapV2Pair uniswapPair = IUniswapV2Pair(pair);\r\n        address _token0 = uniswapPair.token0();\r\n        address _token1 = uniswapPair.token1();\r\n        require(_token0 == token || _token1 == token, \"Invalid pair\");\r\n        (uint256 _reserve0, uint256 _reserve1, ) = uniswapPair.getReserves();\r\n        require(_reserve0 > 0 && _reserve1 > 0, \"No reserves\");\r\n        uint8 _token0MissingDecimals = 18 - (ERC20(_token0).decimals());\r\n        uint8 _token1MissingDecimals = 18 - (ERC20(_token1).decimals());\r\n        uint256 _price = 0;\r\n        if (token == _token0) {\r\n            _price = (_reserve1 * (10**_token1MissingDecimals) * pricePrecision) / _reserve0;\r\n        } else {\r\n            _price = (_reserve0 * (10**_token0MissingDecimals) * pricePrecision) / _reserve1;\r\n        }\r\n        return _price;\r\n    }\r\n\r\n    function currentBlockTimestamp() internal view returns (uint32) {\r\n        return uint32(block.timestamp % 2**32);\r\n    }\r\n\r\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\r\n    function currentCumulativePrices(address _pair)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 price0Cumulative,\r\n            uint256 price1Cumulative,\r\n            uint32 blockTimestamp\r\n        )\r\n    {\r\n        blockTimestamp = currentBlockTimestamp();\r\n        IUniswapV2Pair uniswapPair = IUniswapV2Pair(_pair);\r\n        price0Cumulative = uniswapPair.price0CumulativeLast();\r\n        price1Cumulative = uniswapPair.price1CumulativeLast();\r\n\r\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\r\n        (uint112 reserve0, uint112 reserve1, uint32 _blockTimestampLast) = uniswapPair.getReserves();\r\n        unchecked {\r\n            if (_blockTimestampLast != blockTimestamp) {\r\n                // subtraction overflow is desired\r\n                uint32 timeElapsed = blockTimestamp - _blockTimestampLast;\r\n                // addition overflow is desired\r\n                // counterfactual\r\n                price0Cumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\r\n                // counterfactual\r\n                price1Cumulative += uint256(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\r\n            }\r\n        }\r\n    }\r\n\r\n    // EVENTS\r\n    event PeriodUpdated(uint256 _period);\r\n}\r\n"
    },
    "contracts/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport \"./interfaces/IXToken.sol\";\r\nimport \"./interfaces/IYToken.sol\";\r\nimport \"./interfaces/IYTokenReserve.sol\";\r\nimport \"./interfaces/IMasterOracle.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\nimport \"./interfaces/ISwapStrategy.sol\";\r\nimport \"./libs/WethUtils.sol\";\r\n\r\ncontract Pool is Ownable, ReentrancyGuard {\r\n    using SafeERC20 for ERC20;\r\n    using SafeERC20 for IWETH;\r\n    using SafeERC20 for IXToken;\r\n    using SafeERC20 for IYToken;\r\n\r\n    struct UserInfo {\r\n        uint256 xTokenBalance;\r\n        uint256 yTokenBalance;\r\n        uint256 ethBalance;\r\n        uint256 lastAction;\r\n    }\r\n\r\n    /* ========== ADDRESSES ================ */\r\n\r\n    IMasterOracle public oracle;\r\n    IXToken public xToken;\r\n    IYToken public yToken;\r\n    IYTokenReserve public yTokenReserve;\r\n    ISwapStrategy public swapStrategy;\r\n    address public treasury;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    mapping(address => UserInfo) public userInfo;\r\n\r\n    uint256 public unclaimedEth;\r\n    uint256 public unclaimedXToken;\r\n    uint256 public unclaimedYToken;\r\n\r\n    // Constants for various precisions\r\n    uint256 private constant PRICE_PRECISION = 1e18;\r\n    uint256 private constant COLLATERAL_RATIO_MAX = 1e6;\r\n    uint256 private constant PRECISION = 1e6;\r\n\r\n    // AccessControl state variables\r\n    bool public mintPaused = false;\r\n    bool public redeemPaused = false;\r\n\r\n    // Collateral ratio\r\n    uint256 public collateralRatio = 1e6;\r\n    uint256 public lastRefreshCrTimestamp;\r\n    uint256 public refreshCooldown = 3600; // = 1 hour\r\n    uint256 public ratioStepUp = 2000; // = 0.002 or 0.2% -> ratioStep when CR increase\r\n    uint256 public ratioStepDown = 1000; // = 0.001 or 0.1% -> ratioStep when CR decrease\r\n    uint256 public priceTarget = 1e18; // = 1; 1 XToken pegged to the value of 1 ETH\r\n    uint256 public priceBand = 5e15; // = 0.005; CR will be adjusted if XToken > 1.005 ETH or XToken < 0.995 ETH\r\n    uint256 public minCollateralRatio = 1e6;\r\n    uint256 public yTokenSlippage = 100000; // 10%\r\n    bool public collateralRatioPaused = false;\r\n\r\n    // fees\r\n    uint256 public redemptionFee = 5000; // 6 decimals of precision, .5%\r\n    uint256 public constant REDEMPTION_FEE_MAX = 9000; // 0.9%\r\n    uint256 public mintingFee = 3000; // 6 decimals of precision, .3%\r\n    uint256 public constant MINTING_FEE_MAX = 5000; // 0.5%\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        address _xToken,\r\n        address _yToken,\r\n        address _yTokenReserve\r\n    ) {\r\n        require(_xToken != address(0), \"Pool::initialize: invalidAddress\");\r\n        require(_yToken != address(0), \"Pool::initialize: invalidAddress\");\r\n        require(_yTokenReserve != address(0), \"Pool::initialize: invalidAddress\");\r\n        xToken = IXToken(_xToken);\r\n        xToken.setMinter(address(this));\r\n        yToken = IYToken(_yToken);\r\n        yTokenReserve = IYTokenReserve(_yTokenReserve);\r\n        yTokenReserve.setPool(address(this));\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function info()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _collateralRatio,\r\n            uint256 _lastRefreshCrTimestamp,\r\n            uint256 _mintingFee,\r\n            uint256 _redemptionFee,\r\n            bool _mintingPaused,\r\n            bool _redemptionPaused,\r\n            uint256 _collateralBalance\r\n        )\r\n    {\r\n        _collateralRatio = collateralRatio;\r\n        _lastRefreshCrTimestamp = lastRefreshCrTimestamp;\r\n        _mintingFee = mintingFee;\r\n        _redemptionFee = redemptionFee;\r\n        _mintingPaused = mintPaused;\r\n        _redemptionPaused = redeemPaused;\r\n        _collateralBalance = usableCollateralBalance();\r\n    }\r\n\r\n    function usableCollateralBalance() public view returns (uint256) {\r\n        uint256 _balance = WethUtils.weth.balanceOf(address(this));\r\n        return _balance > unclaimedEth ? (_balance - unclaimedEth) : 0;\r\n    }\r\n\r\n    function getXSupplyAndUnclaimed() public view returns (uint256) {\r\n        return ((xToken.totalSupply()) + (unclaimedXToken));\r\n    }\r\n\r\n    function realCollateralRatio () public view returns (uint256) {\r\n        return ((usableCollateralBalance()) * (1000000)) / (getXSupplyAndUnclaimed());\r\n    }\r\n\r\n    /// @notice Calculate the expected results for zap minting\r\n    /// @param _ethIn Amount of Collateral token input.\r\n    /// @return _xTokenOut : the amount of XToken output.\r\n    /// @return _yTokenOutTwap : the amount of YToken output by swapping based on Twap price\r\n    /// @return _ethFee : the fee amount in Collateral token.\r\n    /// @return _ethSwapIn : the amount of Collateral token to swap\r\n    function calcMint(uint256 _ethIn)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _xTokenOut,\r\n            uint256 _yTokenOutTwap,\r\n            uint256 _ethFee,\r\n            uint256 _ethSwapIn\r\n        )\r\n    {\r\n        uint256 _yTokenTwap = oracle.getYTokenTWAP();\r\n        require(_yTokenTwap > 0, \"Pool::calcMint: Invalid YToken price\");\r\n        _ethSwapIn = (_ethIn * (COLLATERAL_RATIO_MAX - collateralRatio)) / COLLATERAL_RATIO_MAX;\r\n        _yTokenOutTwap = (_ethSwapIn * PRICE_PRECISION) / _yTokenTwap;\r\n        _ethFee = (_ethIn * mintingFee * collateralRatio) / COLLATERAL_RATIO_MAX / PRECISION;\r\n        _xTokenOut = _ethIn - ((_ethIn * mintingFee) / PRECISION);\r\n    }\r\n\r\n    /// @notice Calculate the expected results for redemption\r\n    /// @param _xTokenIn Amount of XToken input.\r\n    /// @return _ethOut : the amount of Eth output\r\n    /// @return _yTokenOutSpot : the amount of YToken output based on Spot prrice\r\n    /// @return _yTokenOutTwap : the amount of YToken output based on TWAP\r\n    /// @return _ethFee : the fee amount in Eth\r\n    /// @return _requiredEthBalance : required Eth balance in the pool\r\n    function calcRedeem(uint256 _xTokenIn)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _ethOut,\r\n            uint256 _yTokenOutSpot,\r\n            uint256 _yTokenOutTwap,\r\n            uint256 _ethFee,\r\n            uint256 _requiredEthBalance\r\n        )\r\n    {\r\n        uint256 _yTokenPrice = oracle.getYTokenPrice();\r\n        uint256 _yTokenTWAP = oracle.getYTokenTWAP();\r\n        require(_yTokenPrice > 0, \"Pool::calcRedeem: Invalid YToken price\");\r\n\r\n        _requiredEthBalance = (_xTokenIn * collateralRatio) / PRECISION;\r\n        if (collateralRatio < COLLATERAL_RATIO_MAX) {\r\n            _yTokenOutSpot = (_xTokenIn * (COLLATERAL_RATIO_MAX - collateralRatio) * (PRECISION - redemptionFee) * PRICE_PRECISION) / COLLATERAL_RATIO_MAX / PRECISION / _yTokenPrice;\r\n            _yTokenOutTwap = (_xTokenIn * (COLLATERAL_RATIO_MAX - collateralRatio) * (PRECISION - redemptionFee) * PRICE_PRECISION) / COLLATERAL_RATIO_MAX / PRECISION / _yTokenTWAP;\r\n        }\r\n\r\n        if (collateralRatio > 0) {\r\n            _ethOut = (_xTokenIn * collateralRatio * (PRECISION - redemptionFee)) / COLLATERAL_RATIO_MAX / PRECISION;\r\n            _ethFee = (_xTokenIn * collateralRatio * redemptionFee) / COLLATERAL_RATIO_MAX / PRECISION;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculate the excess collateral balance\r\n    function calcExcessCollateralBalance() public view returns (uint256 _delta, bool _exceeded) {\r\n        uint256 _requiredCollateralBal = (xToken.totalSupply() * collateralRatio) / COLLATERAL_RATIO_MAX;\r\n        uint256 _usableCollateralBal = usableCollateralBalance();\r\n        if (_usableCollateralBal >= _requiredCollateralBal) {\r\n            _delta = _usableCollateralBal - _requiredCollateralBal;\r\n            _exceeded = true;\r\n        } else {\r\n            _delta = _requiredCollateralBal - _usableCollateralBal;\r\n            _exceeded = false;\r\n        }\r\n    }\r\n\r\n    /* ========== PUBLIC FUNCTIONS ========== */\r\n\r\n    /// @notice Update collateral ratio and adjust based on the TWAP price of XToken\r\n    function refreshCollateralRatio() public {\r\n        require(collateralRatioPaused == false, \"Pool::refreshCollateralRatio: Collateral Ratio has been paused\");\r\n        require(block.timestamp - lastRefreshCrTimestamp >= refreshCooldown, \"Pool::refreshCollateralRatio: Must wait for the refresh cooldown since last refresh\");\r\n\r\n        uint256 _xTokenPrice = oracle.getXTokenTWAP();\r\n        if (_xTokenPrice > priceTarget + priceBand) {\r\n            if (collateralRatio <= ratioStepDown) {\r\n                collateralRatio = 0;\r\n            } else {\r\n                uint256 _newCR = collateralRatio - ratioStepDown;\r\n                if (_newCR <= minCollateralRatio) {\r\n                    collateralRatio = minCollateralRatio;\r\n                } else {\r\n                    collateralRatio = _newCR;\r\n                }\r\n            }\r\n        } else if (_xTokenPrice < priceTarget - priceBand) {\r\n            if (collateralRatio + ratioStepUp >= COLLATERAL_RATIO_MAX) {\r\n                collateralRatio = COLLATERAL_RATIO_MAX;\r\n            } else {\r\n                collateralRatio = collateralRatio + ratioStepUp;\r\n            }\r\n        }\r\n\r\n        lastRefreshCrTimestamp = block.timestamp;\r\n        emit NewCollateralRatioSet(collateralRatio);\r\n    }\r\n\r\n    /// @notice fallback for payable -> required to unwrap WETH\r\n    receive() external payable {}\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    function mint(uint256 _minXTokenOut) external payable nonReentrant {\r\n        require(!mintPaused, \"Pool::mint: Minting is paused\");\r\n        uint256 _ethIn = msg.value;\r\n        address _sender = msg.sender;\r\n\r\n        (uint256 _xTokenOut, uint256 _yTokenOutTwap, uint256 _fee, uint256 _wethSwapIn) = calcMint(_ethIn);\r\n        require(_xTokenOut >= _minXTokenOut, \"Pool::mint: > slippage\");\r\n\r\n        WethUtils.wrap(_ethIn);\r\n        if (_yTokenOutTwap > 0 && _wethSwapIn > 0) {\r\n            WethUtils.weth.safeIncreaseAllowance(address(swapStrategy), _wethSwapIn);\r\n            swapStrategy.execute(_wethSwapIn, _yTokenOutTwap);\r\n        }\r\n\r\n        if (_xTokenOut > 0) {\r\n            userInfo[_sender].xTokenBalance = userInfo[_sender].xTokenBalance + _xTokenOut;\r\n            unclaimedXToken = unclaimedXToken + _xTokenOut;\r\n        }\r\n\r\n        transferToTreasury(_fee);\r\n\r\n        emit Mint(_sender, _xTokenOut, _ethIn, _fee);\r\n    }\r\n\r\n    function redeem(\r\n        uint256 _xTokenIn,\r\n        uint256 _minYTokenOut,\r\n        uint256 _minEthOut\r\n    ) external nonReentrant {\r\n        require(!redeemPaused, \"Pool::redeem: Redeeming is paused\");\r\n\r\n        address _sender = msg.sender;\r\n        (uint256 _ethOut, uint256 _yTokenOutSpot, uint256 _yTokenOutTwap, uint256 _fee, uint256 _requiredEthBalance) = calcRedeem(_xTokenIn);\r\n\r\n        // Check if collateral balance meets and meet output expectation\r\n        require(_requiredEthBalance <= usableCollateralBalance(), \"Pool::redeem: > ETH balance\");\r\n\r\n        // Prevent price manipulation to get more yToken\r\n        checkPriceFluctuation(_yTokenOutSpot, _yTokenOutTwap);\r\n\r\n        require(_minEthOut <= _ethOut && _minYTokenOut <= _yTokenOutSpot, \"Pool::redeem: >slippage\");\r\n\r\n        if (_ethOut > 0) {\r\n            userInfo[_sender].ethBalance = userInfo[_sender].ethBalance + _ethOut;\r\n            unclaimedEth = unclaimedEth + _ethOut;\r\n        }\r\n\r\n        if (_yTokenOutSpot > 0) {\r\n            userInfo[_sender].yTokenBalance = userInfo[_sender].yTokenBalance + _yTokenOutSpot;\r\n            unclaimedYToken = unclaimedYToken + _yTokenOutSpot;\r\n        }\r\n\r\n        userInfo[_sender].lastAction = block.number;\r\n\r\n        // Move all external functions to the end\r\n        xToken.burnFrom(_sender, _xTokenIn);\r\n        transferToTreasury(_fee);\r\n\r\n        emit Redeem(_sender, _xTokenIn, _ethOut, _yTokenOutSpot, _fee);\r\n    }\r\n\r\n    /**\r\n     * @notice collect all minting and redemption\r\n     */\r\n    function collect() external nonReentrant {\r\n        address _sender = msg.sender;\r\n        require(userInfo[_sender].lastAction < block.number, \"Pool::collect: <minimum_delay\");\r\n\r\n        bool _sendXToken = false;\r\n        bool _sendYToken = false;\r\n        bool _sendEth = false;\r\n        uint256 _xTokenAmount;\r\n        uint256 _yTokenAmount;\r\n        uint256 _ethAmount;\r\n\r\n        // Use Checks-Effects-Interactions pattern\r\n        if (userInfo[_sender].xTokenBalance > 0) {\r\n            _xTokenAmount = userInfo[_sender].xTokenBalance;\r\n            userInfo[_sender].xTokenBalance = 0;\r\n            unclaimedXToken = unclaimedXToken - _xTokenAmount;\r\n            _sendXToken = true;\r\n        }\r\n\r\n        if (userInfo[_sender].yTokenBalance > 0) {\r\n            _yTokenAmount = userInfo[_sender].yTokenBalance;\r\n            userInfo[_sender].yTokenBalance = 0;\r\n            unclaimedYToken = unclaimedYToken - _yTokenAmount;\r\n            _sendYToken = true;\r\n        }\r\n\r\n        if (userInfo[_sender].ethBalance > 0) {\r\n            _ethAmount = userInfo[_sender].ethBalance;\r\n            userInfo[_sender].ethBalance = 0;\r\n            unclaimedEth = unclaimedEth - _ethAmount;\r\n            _sendEth = true;\r\n        }\r\n\r\n        if (_sendXToken) {\r\n            xToken.mint(_sender, _xTokenAmount);\r\n        }\r\n\r\n        if (_sendYToken) {\r\n            yTokenReserve.transfer(_sender, _yTokenAmount);\r\n        }\r\n\r\n        if (_sendEth) {\r\n            WethUtils.unwrap(_ethAmount);\r\n            Address.sendValue(payable(_sender), _ethAmount);\r\n        }\r\n    }\r\n\r\n    /// @notice Function to recollateralize the pool by receiving ETH\r\n    function recollateralize() external payable {\r\n        uint256 _amount = msg.value;\r\n        require(_amount > 0, \"Pool::recollateralize: Invalid amount\");\r\n        WethUtils.wrap(_amount);\r\n        emit Recollateralized(msg.sender, _amount);\r\n    }\r\n\r\n     function checkPriceFluctuation(uint256 _yAmountSpotPrice, uint256 _yAmountTwap) internal view {\r\n        uint256 _diff;\r\n        if (_yAmountSpotPrice > _yAmountTwap) {\r\n            _diff = _yAmountSpotPrice - _yAmountTwap;\r\n        } else {\r\n            _diff = _yAmountTwap - _yAmountSpotPrice;\r\n        }\r\n        require(_diff <= ((_yAmountTwap * yTokenSlippage) / PRECISION), \"Pool::checkPriceFluctuation: > yTokenSlippage\");\r\n    }\r\n\r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n\r\n    /// @notice Turn on / off minting and redemption\r\n    /// @param _mintPaused Paused or NotPaused Minting\r\n    /// @param _redeemPaused Paused or NotPaused Redemption\r\n    function toggle(bool _mintPaused, bool _redeemPaused) public onlyOwner {\r\n        mintPaused = _mintPaused;\r\n        redeemPaused = _redeemPaused;\r\n        emit Toggled(_mintPaused, _redeemPaused);\r\n    }\r\n\r\n    /// @notice Configure variables related to Collateral Ratio\r\n    /// @param _ratioStepUp Step which Collateral Ratio will be increased each updates\r\n    /// @param _ratioStepDown Step which Collateral Ratio will be decreased each updates\r\n    /// @param _priceBand The collateral ratio will only be adjusted if current price move out of this band\r\n    /// @param _refreshCooldown The minimum delay between each Collateral Ratio updates\r\n    function setCollateralRatioOptions(\r\n        uint256 _ratioStepUp,\r\n        uint256 _ratioStepDown,\r\n        uint256 _priceBand,\r\n        uint256 _refreshCooldown\r\n    ) public onlyOwner {\r\n        ratioStepUp = _ratioStepUp;\r\n        ratioStepDown = _ratioStepDown;\r\n        priceBand = _priceBand;\r\n        refreshCooldown = _refreshCooldown;\r\n        emit NewCollateralRatioOptions(_ratioStepUp, _ratioStepDown, _priceBand, _refreshCooldown);\r\n    }\r\n\r\n    /// @notice Pause or unpause collateral ratio updates\r\n    /// @param _collateralRatioPaused `true` or `false`\r\n    function toggleCollateralRatio(bool _collateralRatioPaused) public onlyOwner {\r\n        if (collateralRatioPaused != _collateralRatioPaused) {\r\n            collateralRatioPaused = _collateralRatioPaused;\r\n            emit UpdateCollateralRatioPaused(_collateralRatioPaused);\r\n        }\r\n    }\r\n\r\n    /// @notice Set the protocol fees\r\n    /// @param _mintingFee Minting fee in percentage\r\n    /// @param _redemptionFee Redemption fee in percentage\r\n    function setFees(uint256 _mintingFee, uint256 _redemptionFee) public onlyOwner {\r\n        require(_mintingFee <= MINTING_FEE_MAX, \"Pool::setFees:>MINTING_FEE_MAX\");\r\n        require(_redemptionFee <= REDEMPTION_FEE_MAX, \"Pool::setFees:>REDEMPTION_FEE_MAX\");\r\n        redemptionFee = _redemptionFee;\r\n        mintingFee = _mintingFee;\r\n        emit FeesUpdated(_mintingFee, _redemptionFee);\r\n    }\r\n\r\n    /// @notice Set the minimum Collateral Ratio\r\n    /// @param _minCollateralRatio value of minimum Collateral Ratio in 1e6 precision\r\n    function setMinCollateralRatio(uint256 _minCollateralRatio) external onlyOwner {\r\n        require(_minCollateralRatio <= COLLATERAL_RATIO_MAX, \"Pool::setMinCollateralRatio: >COLLATERAL_RATIO_MAX\");\r\n        minCollateralRatio = _minCollateralRatio;\r\n        emit MinCollateralRatioUpdated(_minCollateralRatio);\r\n    }\r\n\r\n    /// @notice Transfer the excess balance of WETH to FeeReserve\r\n    /// @param _amount amount of WETH to reduce\r\n    function reduceExcessCollateral(uint256 _amount) external onlyOwner {\r\n        (uint256 _excessWethBal, bool exceeded) = calcExcessCollateralBalance();\r\n        if (exceeded && _excessWethBal > 0) {\r\n            require(_amount <= _excessWethBal, \"Pool::reduceExcessCollateral: The amount is too large\");\r\n            transferToTreasury(_amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Set the address of Swapper utils\r\n    /// @param _swapStrategy address of Swapper utils contract\r\n    function setSwapStrategy(ISwapStrategy _swapStrategy) external onlyOwner {\r\n        require(address(_swapStrategy) != address(0), \"Pool::setSwapStrategy: invalid address\");\r\n        swapStrategy = _swapStrategy;\r\n        emit SwapStrategyChanged(address(_swapStrategy));\r\n    }\r\n\r\n    /// @notice Set new oracle address\r\n    /// @param _oracle address of the oracle\r\n    function setOracle(IMasterOracle _oracle) external onlyOwner {\r\n        require(address(_oracle) != address(0), \"Pool::setOracle: invalid address\");\r\n        oracle = _oracle;\r\n        emit OracleChanged(address(_oracle));\r\n    }\r\n\r\n    /// @notice Set yTokenSlipage\r\n    function setYTokenSlippage(uint256 _slippage) external onlyOwner {\r\n        require(_slippage <= 300000, \"Pool::setYTokenSlippage: yTokenSlippage cannot be more than 30%\");\r\n        yTokenSlippage = _slippage;\r\n        emit YTokenSlippageSet(_slippage);\r\n    }\r\n\r\n    /// @notice Set the address of Treasury\r\n    /// @param _treasury address of Treasury contract\r\n    function setTreasury(address _treasury) external {\r\n        require(treasury == address(0), \"Pool::setTreasury: not allowed\");\r\n        treasury = _treasury;\r\n        emit TreasurySet(_treasury);\r\n    }\r\n\r\n    /// @notice Move weth to treasury\r\n    function transferToTreasury(uint256 _amount) internal {\r\n        require(treasury != address(0), \"Pool::transferToTreasury:Invalid address\");\r\n        if (_amount > 0) {\r\n            WethUtils.weth.safeTransfer(treasury, _amount);\r\n        }\r\n    }\r\n\r\n    // Arber only\r\n    IUniswapV2Router02 public uniswapV2Router02; \r\n    mapping (address => bool) public arbers; \r\n    address[] public xTokenWethPath;\r\n    address[] public wethXTokenPath;\r\n    address[] public yTokenWethPath;\r\n\r\n    function setRouter (address _uniswapV2Router02) public onlyOwner () {\r\n        uniswapV2Router02 = IUniswapV2Router02(_uniswapV2Router02);\r\n    }\r\n\r\n    function approveArber (address _arber) public onlyOwner () {\r\n        arbers[_arber] = true;\r\n    }\r\n\r\n    function revokeArber (address _arber) public onlyOwner () {\r\n        arbers[_arber] = false;\r\n    }\r\n\r\n    function setXTokenWethPath (address[] memory _xTokenWethPath) public onlyOwner () {\r\n        delete xTokenWethPath;\r\n        for (uint256 i = 0; i < _xTokenWethPath.length; i++) {\r\n            xTokenWethPath.push(_xTokenWethPath[i]);\r\n        }\r\n    }\r\n\r\n    \r\n    function setWethXTokenPath (address [] memory _wethXTokenPath) public onlyOwner () {\r\n        delete wethXTokenPath;\r\n        for (uint256 i = 0; i < _wethXTokenPath.length; i++) {\r\n            wethXTokenPath.push(_wethXTokenPath[i]);\r\n        }\r\n    }\r\n\r\n\r\n    function setYTokenWethPath (address [] memory _yTokenWethPath) public onlyOwner () {\r\n        delete yTokenWethPath;\r\n        for (uint256 i = 0; i < _yTokenWethPath.length; i++) {\r\n            yTokenWethPath.push(_yTokenWethPath[i]);\r\n        }\r\n    }\r\n\r\n\r\n    modifier onlyArber () {\r\n        require (arbers[msg.sender], \"Pool::onlyArber: only approved arber can call this\");\r\n        _;\r\n    }\r\n\r\n\r\n    /** @notice Calculate the expected results for redemption by approved arber\r\n        @param _xTokenIn Amount of XToken input.\r\n        @return _ethOut : the amount of Eth output\r\n        @return _yTokenOutSpot : the amount of YToken output based on Spot price\r\n        @return _requiredEthBalance : required Eth balance in the pool\r\n    */\r\n    function arberCalcRedeem(uint256 _xTokenIn)\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _ethOut,\r\n            uint256 _yTokenOutSpot,\r\n            uint256 _requiredEthBalance\r\n        )\r\n    {\r\n        uint256 _yTokenPrice = oracle.getYTokenPrice();\r\n        require(_yTokenPrice > 0, \"Pool::calcRedeem: Invalid YToken price\");\r\n        \r\n        uint256 _realCollateralRatio = realCollateralRatio();\r\n        if (_realCollateralRatio > COLLATERAL_RATIO_MAX) {\r\n            _realCollateralRatio = COLLATERAL_RATIO_MAX;\r\n        }\r\n\r\n        _requiredEthBalance = (_xTokenIn * _realCollateralRatio) / PRECISION;\r\n        if (_realCollateralRatio < COLLATERAL_RATIO_MAX) { // COLLATERAL_RATIO_MAX == 100%\r\n            _yTokenOutSpot = (_xTokenIn * (COLLATERAL_RATIO_MAX - _realCollateralRatio) * (PRECISION) * PRICE_PRECISION) / COLLATERAL_RATIO_MAX / PRECISION / _yTokenPrice;\r\n        }\r\n\r\n        if (_realCollateralRatio > 0) {\r\n            _ethOut = (_xTokenIn * _realCollateralRatio * (PRECISION)) / COLLATERAL_RATIO_MAX / PRECISION;\r\n        }\r\n    }\r\n\r\n    /** \r\n        @notice mint and sell xTokens when over peg, requires that >= 1 WETH per minted xToken is recieved.\r\n        @param _xTokenAmount amount of xTokens to mint and sell\r\n    */\r\n    function arberMint(uint256 _xTokenAmount) external onlyArber {\r\n        uint256 _startWethBalance = WethUtils.weth.balanceOf(address(this));\r\n        uint256[] memory _amountsOut = uniswapV2Router02.getAmountsOut(_xTokenAmount, xTokenWethPath);\r\n        uint256 _ethOut = _amountsOut[_amountsOut.length - 1];\r\n        require(_ethOut >= _xTokenAmount, \"Pool::arberMint: mint must result in atleast 100% collateralisation of new xTokens\");\r\n        xToken.mint(address(this), _xTokenAmount);\r\n        xToken.safeIncreaseAllowance(address(uniswapV2Router02), _xTokenAmount);\r\n        uniswapV2Router02.swapExactTokensForTokens(_xTokenAmount, _ethOut, xTokenWethPath, address(this), block.timestamp);\r\n        uint256 _wethGained = (WethUtils.weth.balanceOf(address(this))) - (_startWethBalance);\r\n        require (_wethGained >= _ethOut, \"Pool::arberMint: mint did not result in 100% collateralization of new xTokens\");\r\n        emit ArberMint(block.timestamp, _xTokenAmount, _wethGained);\r\n    }\r\n\r\n    function arberBuybackRedeem(uint256 _wethBorrow) external onlyArber {\r\n        require(_wethBorrow <= usableCollateralBalance(), \"Pool::arberBuyBackRedeem: borrow exceeds weth balance\");\r\n        uint256 _startWethBalance = usableCollateralBalance();\r\n        uint256 _startCR = realCollateralRatio();\r\n\r\n        uint256[] memory _amountsOut = uniswapV2Router02.getAmountsOut(_wethBorrow, wethXTokenPath);\r\n        uint256 _xTokenIn = _amountsOut[_amountsOut.length - 1];\r\n        (uint256 _ethOut, uint256 _yTokenOutSpot, uint256 _requiredEthBalance) = arberCalcRedeem(_xTokenIn);\r\n        \r\n        uint256 _wethRecievedFromYSwap;\r\n        if (_yTokenOutSpot > 0) {\r\n            _amountsOut = uniswapV2Router02.getAmountsOut(_yTokenOutSpot, yTokenWethPath);\r\n            _wethRecievedFromYSwap = _amountsOut[_amountsOut.length - 1];\r\n        } else {\r\n            _wethRecievedFromYSwap = 0;\r\n        }\r\n\r\n        uint256 _projectedEndWeth = (_startWethBalance - (_wethBorrow)) + (_wethRecievedFromYSwap);\r\n        uint256 _projectedEndXSupply = (getXSupplyAndUnclaimed()) - (_xTokenIn);\r\n        uint256 _projectedCR = (_projectedEndWeth * (1000000)) / (_projectedEndXSupply);\r\n        require(_projectedCR >= _startCR, \"Pool::arberBuyBackRedeem: must maintain or improve collateral ratio\");\r\n\r\n        // Move all external functions to the end\r\n        WethUtils.weth.safeIncreaseAllowance(address(uniswapV2Router02), _wethBorrow);\r\n        uniswapV2Router02.swapExactTokensForTokens(_wethBorrow, _xTokenIn, wethXTokenPath, address(this), block.timestamp);\r\n        \r\n        xToken.burn(_xTokenIn);\r\n        \r\n        if (_yTokenOutSpot > 0) {\r\n            yTokenReserve.transfer(address(this), _yTokenOutSpot);\r\n            yToken.safeIncreaseAllowance(address(uniswapV2Router02), _yTokenOutSpot);\r\n            uniswapV2Router02.swapExactTokensForTokens(_yTokenOutSpot, _wethRecievedFromYSwap, yTokenWethPath, address(this), block.timestamp);\r\n        }\r\n        uint256 _endCR = realCollateralRatio();\r\n        require(_endCR >= _startCR, \"Pool::arberBuyBackRedeem: did not maintain or improve collateral ratio\");\r\n        emit ArberBuybackRedeemed(block.timestamp, _endCR);\r\n    }\r\n\r\n\r\n    /**\r\n        @notice Transfer the excess balance of WETH to arber\r\n        @param _amount amount of WETH to reduce\r\n    */\r\n    function arberWithdrawExcessCollateral(uint256 _amount) external onlyArber {\r\n        (uint256 _excessWethBal, bool exceeded) = calcExcessCollateralBalance();\r\n        if (exceeded && _excessWethBal > 0) {\r\n            require(_amount <= _excessWethBal, \"Pool::arberWithdrawExcessCollateral: The amount exceeds surplus\");\r\n            WethUtils.transfer(msg.sender, _amount);\r\n        }\r\n    }\r\n\r\n    // EVENTS\r\n    event OracleChanged(address indexed _oracle);\r\n    event Toggled(bool _mintPaused, bool _redeemPaused);\r\n    event Mint(address minter, uint256 amount, uint256 ethIn, uint256 fee);\r\n    event Redeem(address redeemer, uint256 amount, uint256 ethOut, uint256 yTokenOut, uint256 fee);\r\n    event UpdateCollateralRatioPaused(bool _collateralRatioPaused);\r\n    event NewCollateralRatioOptions(uint256 _ratioStepUp, uint256 _ratioStepDown, uint256 _priceBand, uint256 _refreshCooldown);\r\n    event MinCollateralRatioUpdated(uint256 _minCollateralRatio);\r\n    event NewCollateralRatioSet(uint256 _cr);\r\n    event FeesUpdated(uint256 _mintingFee, uint256 _redemptionFee);\r\n    event Recollateralized(address indexed _sender, uint256 _amount);\r\n    event SwapStrategyChanged(address indexed _swapper);\r\n    event TreasurySet(address indexed _treasury);\r\n    event YTokenSlippageSet(uint256 _slippage);\r\n    event ArberMint(uint256 _timestamp, uint256 _xTokenMinted, uint256 _wethGained);\r\n    event ArberBuybackRedeemed(uint256 _timestamp, uint256 _newCR);\r\n}\r\n"
    },
    "contracts/SwapStrategyPOL.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport \"./interfaces/ISwapStrategy.sol\";\r\nimport \"./libs/WethUtils.sol\";\r\n\r\n/*\r\n    Swapper: Protocol Owned Liquidity\r\n    - Swap WETH -> YToken\r\n    - Add liquidity for YToken/WETH pair\r\n    - Transfer LP to Treasury\r\n*/\r\ncontract SwapStrategyPOL is ISwapStrategy, Ownable {\r\n    using SafeERC20 for IWETH;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 public immutable yToken;\r\n    IERC20 public immutable lp;\r\n    IUniswapV2Router02 public immutable swapRouter;\r\n    address[] public swapPaths;\r\n    address public immutable treasury;\r\n    uint256 public swapSlippage = 200000; // 20%\r\n    uint256 private constant SLIPPAGE_PRECISION = 1e6;\r\n\r\n    constructor(\r\n        address _yToken,\r\n        address _lp,\r\n        address _treasury,\r\n        address _swapRouter,\r\n        address[] memory _swapPaths\r\n    ) {\r\n        yToken = IERC20(_yToken);\r\n        lp = IERC20(_lp);\r\n        treasury = _treasury;\r\n        swapRouter = IUniswapV2Router02(_swapRouter);\r\n        swapPaths = _swapPaths;\r\n    }\r\n\r\n    /* ========== VIEW FUNCTIONS ============ */\r\n\r\n    function lpBalance() public view returns (uint256) {\r\n        return lp.balanceOf(address(this));\r\n    }\r\n\r\n    /* ========== PUBLIC FUNCTIONS ============ */\r\n\r\n    /// @notice Function to take input WETH to swap to YToken then add liquidity\r\n    /// @param _wethIn Amount of WETH input\r\n    /// @param _yTokenOut Amount of YToken output expected\r\n    function execute(uint256 _wethIn, uint256 _yTokenOut) external override {\r\n        WethUtils.weth.safeTransferFrom(msg.sender, address(this), _wethIn);\r\n\r\n        // 1. swap 50% of WETH to YToken\r\n        uint256 _wethToSwap = _wethIn / 2;\r\n        uint256 _wethToAdd = _wethIn - _wethToSwap;\r\n        uint256 _minYTokenOut = (_yTokenOut * (SLIPPAGE_PRECISION - swapSlippage)) /\r\n            2 /\r\n            SLIPPAGE_PRECISION;\r\n        uint256 _yTokenReceived = swap(_wethToSwap, _minYTokenOut);\r\n\r\n        // 2. add liquidity for YToken/WETH LP\r\n        addLiquidity(_yTokenReceived, _wethToAdd, swapSlippage);\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ============ */\r\n\r\n    /// @notice Add liquidity for YToken/WETH with the current balance\r\n    function swap(uint256 _wethToSwap, uint256 _minYTokenOut) internal returns (uint256) {\r\n        WethUtils.weth.safeIncreaseAllowance(address(swapRouter), _wethToSwap);\r\n        uint256[] memory _amounts = swapRouter.swapExactTokensForTokens(\r\n            _wethToSwap,\r\n            _minYTokenOut,\r\n            swapPaths,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        return _amounts[swapPaths.length - 1];\r\n    }\r\n\r\n    /// @notice Add liquidity for YToken/WETH with the current balance and Move LP to Treasury\r\n    function addLiquidity(\r\n        uint256 yTokenAmt,\r\n        uint256 wethAmt,\r\n        uint256 slippage\r\n    ) internal {\r\n        require(treasury != address(0), \"SwapStrategyPOL::addLiquidity:Invalid treasury address\");\r\n        if (yTokenAmt > 0 && wethAmt > 0) {\r\n            uint256 _minYTokenOut = (yTokenAmt * (SLIPPAGE_PRECISION - slippage)) /\r\n                SLIPPAGE_PRECISION;\r\n            uint256 _minWethOut = (wethAmt * (SLIPPAGE_PRECISION - slippage)) / SLIPPAGE_PRECISION;\r\n            yToken.safeIncreaseAllowance(address(swapRouter), yTokenAmt);\r\n            WethUtils.weth.safeIncreaseAllowance(address(swapRouter), wethAmt);\r\n            (uint256 _amountA, uint256 _amountB, uint256 _liquidity) = swapRouter.addLiquidity(\r\n                address(yToken),\r\n                address(WethUtils.weth),\r\n                yTokenAmt,\r\n                wethAmt,\r\n                _minYTokenOut,\r\n                _minWethOut,\r\n                treasury,\r\n                block.timestamp\r\n            );\r\n            emit LiquidityAdded(_liquidity, _amountA, _amountB);\r\n        }\r\n    }\r\n\r\n    function cleanDust() external onlyOwner {\r\n        yToken.safeTransfer(treasury, yToken.balanceOf(address(this)));\r\n        WethUtils.weth.safeTransfer(treasury, WethUtils.weth.balanceOf(address(this)));\r\n    }\r\n\r\n    function changeSlippage(uint256 _newSlippage) external onlyOwner {\r\n        require(\r\n            _newSlippage <= SLIPPAGE_PRECISION,\r\n            \"SwapStrategyPOL::changeSlippage: Invalid slippage\"\r\n        );\r\n        swapSlippage = _newSlippage;\r\n        emit SlippageChanged(_newSlippage);\r\n    }\r\n\r\n    /* ========== EVENTS ============ */\r\n\r\n    event LiquidityAdded(uint256 _lpBalance, uint256 _wethAmt, uint256 _yTokenAmt);\r\n    event SlippageChanged(uint256 _newSlippage);\r\n}\r\n"
    },
    "contracts/tokens/goerli/AFX.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"../YToken.sol\";\r\n\r\ncontract AFX is YToken {\r\n    uint256 public constant MAX_TOTAL_SUPPLY = 30_000_000 ether;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _daoFund,\r\n        address _devFund,\r\n        address _treasuryFund,\r\n        address _airdropFund,\r\n        address _reserve\r\n    ) YToken(_name, _symbol) {\r\n        _mint(msg.sender, 100 ether);\r\n        _mint(_daoFund, 3_000_000 ether); // 10%\r\n        _mint(_devFund, 3_000_000 ether); // 10%\r\n        _mint(_treasuryFund, 2_700_000 ether); // 9%\r\n        _mint(_airdropFund, 300_000 ether); // 1%\r\n        _mint(_reserve, MAX_TOTAL_SUPPLY - 9_000_100 ether); // Includes the 100 minted at genesis.\r\n    }\r\n\r\n    // ===== OVERRIDEN =============\r\n\r\n    function maxTotalSupply() internal pure override returns (uint256) {\r\n        return MAX_TOTAL_SUPPLY;\r\n    }\r\n}\r\n"
    },
    "contracts/tokens/goerli/xETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"../XToken.sol\";\r\n\r\ncontract xETH is XToken {\r\n    uint256 public constant GENESIS_SUPPLY = 1 ether; // 1 will be minted at genesis for liq pool seeding\r\n\r\n    constructor(string memory _name, string memory _symbol) XToken(_name, _symbol) {\r\n        _mint(msg.sender, GENESIS_SUPPLY);\r\n    }\r\n}\r\n"
    },
    "contracts/tokens/USDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n\r\ncontract USDC is IERC20, Ownable {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name = \"USD Coin (Arb1)\";\r\n    string private _symbol = \"USDC\";\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor() {\r\n        _mint(owner(), 100000 * 1e6);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 6;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}"
    },
    "contracts/tokens/XToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\n\r\nabstract contract XToken is ERC20Burnable {\r\n    // CONTRACTS\r\n    address public minter;\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyMinter() {\r\n        require(minter == msg.sender, \"XToken::Only minter can request\");\r\n        _;\r\n    }\r\n\r\n    /* ========== CONSTRUCTOR ========= */\r\n\r\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\r\n\r\n    /* ========== MUTATIVE ========== */\r\n\r\n    /// @notice Set minter for XToken (only once)\r\n    /// @param _minter Address of minting Pool\r\n    function setMinter(address _minter) external {\r\n        require(minter == address(0), \"XToken::setMinter: NOT_ALLOWED\");\r\n        minter = _minter;\r\n    }\r\n\r\n    /// @notice Mint new XToken\r\n    /// @param _address Address of receiver\r\n    /// @param _amount Amount of new XToken\r\n    function mint(address _address, uint256 _amount) external onlyMinter {\r\n        _mint(_address, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/tokens/YToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\n\r\nabstract contract YToken is ERC20Burnable {\r\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\r\n\r\n    function maxTotalSupply() internal virtual view returns (uint256);\r\n}\r\n"
    },
    "contracts/treasury/Strat_Recollateralize.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../interfaces/IWonderfulTreasury.sol\";\r\nimport \"../interfaces/IPool.sol\";\r\nimport \"../interfaces/IWETH.sol\";\r\nimport \"../libs/WethUtils.sol\";\r\n\r\ncontract StratRecollateralize is Ownable {\r\n    using SafeERC20 for IWETH;\r\n\r\n    IPool public immutable pool;\r\n    IWonderfulTreasury public immutable treasury;\r\n\r\n    constructor(IWonderfulTreasury _treasury, IPool _pool) {\r\n        treasury = _treasury;\r\n        pool = _pool;\r\n    }\r\n\r\n    /// @notice Recollateralize the minting pool\r\n    /// @param _amount Amount of ETH will be used to recollateralize\r\n    function recollateralize(uint256 _amount) external onlyOwner {\r\n        require(address(pool) != address(0), \"StratRecollateralize::recollateralize:pool not set\");\r\n        require(_amount > 0, \"StratRecollateralize::recollateralize:invalid amount\");\r\n        treasury.requestFund(address(WethUtils.weth), _amount);\r\n        WethUtils.weth.safeTransferFrom(address(treasury), address(this), _amount);\r\n        WethUtils.unwrap(_amount);\r\n        pool.recollateralize{value: _amount}();\r\n        emit Recollateralized(_amount);\r\n    }\r\n\r\n    /// @notice fallback for payable -> required to unwrap WETH\r\n    receive() external payable {}\r\n\r\n    // EVENTS\r\n    event Recollateralized(uint256 amount);\r\n}\r\n"
    },
    "contracts/treasury/Strat_ReduceReserveLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../interfaces/IWonderfulTreasury.sol\";\r\nimport \"../libs/WethUtils.sol\";\r\n\r\ncontract StratReduceReserveLP is Ownable {\r\n    using SafeERC20 for IWETH;\r\n    using SafeERC20 for IERC20;\r\n\r\n    IWonderfulTreasury public treasury;\r\n    IERC20 public yToken;\r\n    address public yTokenFund;\r\n    IERC20 public lp;\r\n    IUniswapV2Router02 public swapRouter;\r\n    address[] public swapPaths;\r\n\r\n    uint256 private constant SLIPPAGE_PRECISION = 1e6;\r\n\r\n    constructor(\r\n        IERC20 _yToken,\r\n        address _yTokenFund,\r\n        IERC20 _lp,\r\n        IUniswapV2Router02 _swapRouter,\r\n        address[] memory _swapPaths,\r\n        IWonderfulTreasury _treasury\r\n    ) {\r\n        yToken = _yToken;\r\n        lp = _lp;\r\n        yTokenFund = _yTokenFund;\r\n        swapRouter = _swapRouter;\r\n        swapPaths = _swapPaths;\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /* ========== RESTRICTIVE FUNCTIONS ============ */\r\n\r\n    /// @notice Remove liqudity, buyback YToken and burn\r\n    /// @param _amount Amount of Liquidity LP token\r\n    function reduceReserve(uint256 _amount, uint256 _minYTokenAmount) external onlyOwner {\r\n        require(_amount > 0, \"StratReduceReserveLP::reduceReserve:invalid amount\");\r\n        require(yTokenFund != address(0), \"StratReduceReserveLP::reduceReserve:invalid address\");\r\n\r\n        treasury.requestFund(address(lp), _amount);\r\n        lp.safeTransferFrom(address(treasury), address(this), _amount);\r\n\r\n        // 1. remove liquidity\r\n        lp.safeIncreaseAllowance(address(swapRouter), _amount);\r\n        swapRouter.removeLiquidity(address(yToken), address(WethUtils.weth), _amount, 0, 0, address(this), block.timestamp);\r\n\r\n        // 2. swap Weth -> YToken\r\n        swap(WethUtils.weth.balanceOf(address(this)), _minYTokenAmount);\r\n\r\n        // 3. Burn YToken in the contract\r\n        uint256 _yTokenAmt = yToken.balanceOf(address(this));\r\n        yToken.safeTransfer(yTokenFund, _yTokenAmt);\r\n\r\n        emit ReserveReduced(_amount, _yTokenAmt);\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ============ */\r\n\r\n    /// @notice Add liquidity for YToken/WETH with the current balance\r\n    function swap(uint256 _wethToSwap, uint256 _minYTokenOut) internal {\r\n        WethUtils.weth.safeIncreaseAllowance(address(swapRouter), _wethToSwap);\r\n        swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(_wethToSwap, _minYTokenOut, swapPaths, address(this), block.timestamp);\r\n    }\r\n\r\n    /* ========== EVENTS ============ */\r\n\r\n    event ReserveReduced(uint256 _lpAmount, uint256 _yTokenBurnAmt);\r\n}\r\n"
    },
    "contracts/treasury/WonderfulTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../interfaces/IWonderfulStaking.sol\";\r\n\r\n/*  WonderfulTreasury.sol ============================================\r\n    The contract is to store the reserve of Wonderful Protocol\r\n    Contract will have a whitelist of strategy contracts which can request funding from Reserve\r\n    These strategy contracts can be used to Allocate fee, Convert reserve to Protocol Owned Liquidity, Recollateralize, etc\r\n==================================================================== */\r\ncontract WonderfulTreasury is Ownable {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    mapping(address => bool) public strategies;\r\n    address[] public strategiesArray;\r\n    IWonderfulStaking public staking;\r\n\r\n    constructor(IWonderfulStaking _staking) {\r\n        staking = _staking;\r\n    }\r\n\r\n    // ========== PUBLIC VIEW FUNCTIONS ============\r\n\r\n    /// @notice Return ERC-20 balance of WonderfulTreasury\r\n    /// @param _token Address of the ERC-20 token\r\n    /// @return Balance of the WonderfulTreasury\r\n    function balanceOf(address _token) public view returns (uint256) {\r\n        return IERC20(_token).balanceOf(address(this));\r\n    }\r\n\r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n\r\n    /// @notice Request fund from Reserve - only can be called from whitelisted strategies\r\n    /// @param _token Address of the ERC-20 token\r\n    /// @param _amount The requested amount\r\n    function requestFund(address _token, uint256 _amount) external {\r\n        require(strategies[msg.sender], \"WonderfulTreasury::requestFund: Only strategies can request fund\");\r\n        require(_amount <= balanceOf(_token), \"WonderfulTreasury::requestFund: Request more fund than balance\");\r\n        IERC20(_token).safeIncreaseAllowance(msg.sender, _amount);\r\n        emit FundRequested(msg.sender, _amount);\r\n    }\r\n\r\n    /// @notice Add new strategy\r\n    /// @param _strategy Address of the strategy contract\r\n    function addStrategy(address _strategy) external onlyOwner {\r\n        require(_strategy != address(0), \"WonderfulTreasury::addStrategy: invalid address\");\r\n        require(!strategies[_strategy], \"WonderfulTreasury::addStrategy: strategy was previously added\");\r\n        strategies[_strategy] = true;\r\n        strategiesArray.push(_strategy);\r\n        emit StrategyAdded(_strategy);\r\n    }\r\n\r\n    /// @notice Remove current strategy\r\n    /// @param _strategy Address of the strategy contract\r\n    function removeStrategy(address _strategy) external onlyOwner {\r\n        require(strategies[_strategy], \"WonderfulTreasury::removeStrategy: strategy not found\");\r\n        delete strategies[_strategy];\r\n\r\n        for (uint256 i = 0; i < strategiesArray.length; i++) {\r\n            if (strategiesArray[i] == _strategy) {\r\n                strategiesArray[i] = address(0);\r\n                // This will leave a null in the array and keep the indices the same\r\n                break;\r\n            }\r\n        }\r\n        emit StrategyRemoved(_strategy);\r\n    }\r\n\r\n    /// @notice Allocate protocol's fee to stakers\r\n    /// @param _token Address of ERC-20 token\r\n    /// @param _amount Amount of fee will be distributed\r\n    function allocateFee(address _token, uint256 _amount) external onlyOwner {\r\n        require(address(staking) != address(0), \"WonderfulTreasury::allocateFee:Fee distributor not set\");\r\n        require(_amount > 0, \"WonderfulTreasury::allocateFee: invalid amount\");\r\n        IERC20(_token).safeIncreaseAllowance(address(staking), _amount);\r\n        staking.notifyRewardAmount(_token, _amount);\r\n        emit TokenRewardAllocated(_token, _amount);\r\n    }\r\n\r\n    // EVENTS\r\n    event StrategyAdded(address indexed _strategy);\r\n    event StrategyRemoved(address indexed _strategy);\r\n    event FundRequested(address indexed _requester, uint256 _amount);\r\n    event TokenRewardAllocated(address indexed _token, uint256 _amount);\r\n}\r\n"
    },
    "contracts/zap/WonderfulZapSpookySwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\r\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\r\nimport \"../interfaces/IWonderfulChef.sol\";\r\nimport \"../libs/Babylonian.sol\";\r\n\r\n/*\r\n    WonderfulZap is a ZapperFi's simplified version of zapper contract which will:\r\n    1. use ETH to swap to target token\r\n    2. make LP between ETH and target token\r\n    3. add into WonderfulChef farm\r\n*/\r\ncontract WonderfulZapSpookySwap is Ownable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct ZapInfo {\r\n        uint256 pid;\r\n        IERC20 token;\r\n        bool inactive;\r\n    }\r\n\r\n    ZapInfo[] public zaps;\r\n    IWonderfulChef public wonderfulChef;\r\n    IUniswapV2Router02 public uniRouter;\r\n\r\n    address public constant wethAddress = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83; // WFTM\r\n\r\n    constructor(address _wonderfulChef, address _uniRouter) {\r\n        require(_wonderfulChef != address(0), \"Zap::constructor: Invalid address\");\r\n        require(_uniRouter != address(0), \"Zap::constructor: Invalid address\");\r\n        wonderfulChef = IWonderfulChef(_wonderfulChef);\r\n        uniRouter = IUniswapV2Router02(_uniRouter);\r\n    }\r\n\r\n    // ========= MUTATIVE FUNCTION ==============\r\n\r\n    /// @notice Zap function to receive ETH, swap for opposing token,\r\n    /// add liquidity, and deposit LP to farm\r\n    /// @param _zapId: Id of the zap configuration\r\n    /// @param _minLiquidity: Minimum amount of LP received\r\n    /// @param _transferResidual: Flag to determine to transfer dust back to user\r\n    function zap(\r\n        uint256 _zapId,\r\n        uint256 _minLiquidity,\r\n        bool _transferResidual\r\n    ) external payable nonReentrant {\r\n        ZapInfo memory _info = zaps[_zapId];\r\n        require(!_info.inactive, \"Zap::zap: Zap configuration is inactive\");\r\n        uint256 _ethIn = msg.value;\r\n\r\n        address _lp = address(wonderfulChef.lpToken(_info.pid));\r\n        require(_lp != address(0), \"Zap::zap: Invalid LP\");\r\n\r\n        // STEP 1: Swap or Mint token\r\n        (uint256 _ethAmtToSwap, uint256 _tokenAmtToAddLP) = swap(_lp, _ethIn, address(_info.token));\r\n\r\n        // STEP 2: Add liquditiy\r\n        uint256 _ethAmtToAddLP = _ethIn - _ethAmtToSwap;\r\n        approveToken(address(_info.token), address(uniRouter), _tokenAmtToAddLP);\r\n        (uint256 _tokenAmtUsedInLp, uint256 _ethAmtUsedInLp, uint256 _liquidity) = uniRouter\r\n            .addLiquidityETH{value: _ethAmtToAddLP}(\r\n            address(_info.token),\r\n            _tokenAmtToAddLP,\r\n            1,\r\n            1,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        require(_liquidity >= _minLiquidity, \"Zap::zap: Slippage. < minLiquidity\");\r\n\r\n        // STEP 3: Deposit LP to Farm\r\n        approveToken(_lp, address(wonderfulChef), _liquidity);\r\n        wonderfulChef.deposit(_info.pid, _liquidity, msg.sender);\r\n\r\n        // STEP 4: Clean up dust\r\n        if (_transferResidual) {\r\n            if (_tokenAmtToAddLP > _tokenAmtUsedInLp) {\r\n                _info.token.safeTransfer(msg.sender, _tokenAmtToAddLP - _tokenAmtUsedInLp);\r\n            }\r\n            if (_ethAmtToAddLP > _ethAmtUsedInLp) {\r\n                Address.sendValue(payable(msg.sender), _ethAmtToAddLP - _ethAmtUsedInLp);\r\n            }\r\n        }\r\n\r\n        emit Zapped(_zapId, _ethIn, _liquidity);\r\n    }\r\n\r\n    /// @notice fallback for payable -> required to receive WETH\r\n    receive() external payable {}\r\n\r\n    /// @notice Swap internal function to swap from ETH to target Token with calculation\r\n    /// for the appropriate amount of ETH will be used to swap in order to minimize dust\r\n    /// @param _lp: address of the LP pair between WETH and Token\r\n    /// @param _ethIn: Amount of ETH input\r\n    /// @param _token: address of target Token\r\n    function swap(\r\n        address _lp,\r\n        uint256 _ethIn,\r\n        address _token\r\n    ) internal returns (uint256 _ethAmtToSwap, uint256 _tokenAmtReceived) {\r\n        address _token0 = IUniswapV2Pair(_lp).token0();\r\n        (uint256 _res0, uint256 _res1, ) = IUniswapV2Pair(_lp).getReserves();\r\n\r\n        if (_token == _token0) {\r\n            _ethAmtToSwap = calculateSwapInAmount(_res1, _ethIn);\r\n        } else {\r\n            _ethAmtToSwap = calculateSwapInAmount(_res0, _ethIn);\r\n        }\r\n\r\n        if (_ethAmtToSwap <= 0) _ethAmtToSwap = _ethIn / 2;\r\n        _tokenAmtReceived = doSwapETH(_token, _ethAmtToSwap);\r\n    }\r\n\r\n    /// @notice Swap internal function to swap from ETH to target Token\r\n    /// @param _toToken: address of target Token\r\n    /// @param _ethAmt: Amount of ETH input\r\n    function doSwapETH(address _toToken, uint256 _ethAmt)\r\n        internal\r\n        returns (uint256 _tokenReceived)\r\n    {\r\n        address[] memory _path = new address[](2);\r\n        _path[0] = wethAddress;\r\n        _path[1] = _toToken;\r\n\r\n        _tokenReceived = uniRouter.swapExactETHForTokens{value: _ethAmt}(\r\n            1,\r\n            _path,\r\n            address(this),\r\n            block.timestamp\r\n        )[_path.length - 1];\r\n\r\n        require(_tokenReceived > 0, \"Zap::doSwapETH: Error Swapping Tokens 2\");\r\n    }\r\n\r\n    /// @notice Safe approve spending of an token for an address\r\n    /// @param _token: address of target Token\r\n    /// @param _spender: address of spender\r\n    /// @param _amount: Amount of token can be spent\r\n    function approveToken(\r\n        address _token,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) internal {\r\n        IERC20 _erc20Token = IERC20(_token);\r\n        _erc20Token.safeApprove(_spender, 0);\r\n        _erc20Token.safeApprove(_spender, _amount);\r\n    }\r\n\r\n    /// @notice calculate amount to swap just enough so least dust will be leftover when adding liquidity\r\n    /// copied from zapper.fi contract. Assuming 0.2% swap fee\r\n    /// @param _reserveIn: Amount of Reserve for the target token\r\n    /// @param _tokenIn: Amount of total input\r\n    function calculateSwapInAmount(uint256 _reserveIn, uint256 _tokenIn)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return\r\n            (Babylonian.sqrt(_reserveIn * ((_tokenIn * 3992000) + (_reserveIn * 3992004))) -\r\n                (_reserveIn * 1998)) / 1996;\r\n    }\r\n\r\n    // ========= RESTRICTIVE FUNCTIONS ==============\r\n\r\n    /// @notice Add new zap configuration\r\n    /// @param _token: address of target Token\r\n    /// @param _pid: pid in the target farm\r\n    function addZap(address _token, uint256 _pid) external onlyOwner returns (uint256 _zapId) {\r\n        require(_token != address(0), \"Zap::addZap: Invalid address\");\r\n        zaps.push(ZapInfo({token: IERC20(_token), pid: _pid, inactive: false}));\r\n        _zapId = zaps.length - 1;\r\n\r\n        emit ZapAdded(_zapId, _token, _pid);\r\n    }\r\n\r\n    /// @notice Deactivate a Zap configuration\r\n    /// @param _zapId: Id of the zap configuration\r\n    function removeZap(uint256 _zapId) external onlyOwner {\r\n        require(zaps.length > _zapId, \"Zap::removeZap: Invalid zapId\");\r\n        ZapInfo storage info = zaps[_zapId];\r\n        info.inactive = true;\r\n\r\n        emit ZapRemoved(_zapId);\r\n    }\r\n\r\n    // ========= EVENTS ==============\r\n    event ZapAdded(uint256 _id, address _token, uint256 _pid);\r\n    event ZapRemoved(uint256 _id);\r\n    event Zapped(uint256 _zapId, uint256 _amount, uint256 _liquidity);\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}